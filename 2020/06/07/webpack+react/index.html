<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <link rel="manifest" href="/manifest.json">

  
    <meta name="description" content="elegantYu的快乐小屋~">
  

  
    <meta name="keywords" content="技术,前端,学习,交流,javascript,nodejs,vue,插件,杂学,扯淡，教程，工具">
  

  
    <meta name="author" content="elegantYU">
  

  

  

  <title>一分钟搭建webpack+react的chrome-extensions项目 | elegantYu</title>

  

  
    <link rel="icon" href="/favicon.ico">
  

  

  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@latest/build/styles/vs2015.min.css">
<link rel="alternate" href="/atom.xml" title="elegantYu" type="application/atom+xml">
</head>
<body>
  <div class="root-container">
    <!-- navbar -->
<nav class="navbar">
  <div class="navbar-content">
    <!-- logo -->
    <div class="navbar-logo">
      <a href="/">
        
          elegantYu
        
      </a>
    </div>
    <!-- link -->
    <div class="navbar-link">
      <div class="navbar-btn">
        <div></div>
        <div></div>
        <div></div>
      </div>
      <ul class="navbar-list">
        
          <li class="navbar-list-item"><a href="/">home</a></li>
        
          <li class="navbar-list-item"><a href="/categories">categories</a></li>
        
          <li class="navbar-list-item"><a href="/about">about</a></li>
        
      </ul>
    </div>
  </div>
</nav>

    
<!-- header container -->
<header class="header-container post">

  
  

  
  

  
  

  
  

  
  
    <div class="header-content">
      <div class="post-image" style="background-image: url(https://i.loli.net/2020/06/08/CMoiJtfgpNY1jDG.png)"></div>
      <div class="post-text">
        <div class="type-wrap">
          
        </div>
        <h1 class="title-wrap">一分钟搭建webpack+react的chrome-extensions项目</h1>
        <h2 class="title-sub-wrap">
          <strong>elegantYU</strong>
          <span>发布于</span>
          
  <a href="javascript:;" target="_blank" rel="noopener" class="article-date">
    <time datetime="2020-06-07T15:00:38.000Z" itemprop="datePublished">2020-06-07</time>
  </a>

        </h2>
      </div>
    </div>
  

  
  

  </header>

    <!-- 文章 -->

<!-- 文章内容 -->

<div class="body-container">
  <article class="content-container article-container">
    <div class="article-content">
      
      

      <div class="article-entry">
        <p>客厅吹来的徐徐清风，一缕缕带走房间里沉闷的空气，窗外杨树摇摆着夏日繁茂的枝丫，趴在刚换完床单的床上，耳边“梭梭”声若隐若现，大自然的呢喃远比合成的白噪音悦耳。</p>
<p>周日，又一个阳光且慵懒的下午。</p>
<p>这是发布个人第二款浏览器插件<strong>Color Picker</strong>的第二天。</p>
<p>温吞吞的节奏中，慢慢学习使用react去打造插件应用，最终完成提交的那一刹那，心情却如尘埃落定，没有想象中的兴奋之感。<br>我果然还是更重视事件的初衷与过程而非结果，确定了方向后，不断的冲刺，无论道路的狭窄崎岖，只管记住目的，去学习，去克服，一次次的冲锋，一次次的受挫，一次次的进步。<br>这，才是最快乐时候。当到达高潮顶峰之后，只觉得本应如此。</p>
<hr>
<p>闲言碎语不多讲，来看看基础的项目如何构建。</p>
<h1 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h1><p>众所周知，一个webpack的配置主要由<strong>mode(模式)</strong>、<strong>entry(入口)</strong>、<strong>output(出口)</strong>、<strong>loader(转换器)</strong>、<strong>plugin(插件)</strong>构成，下面开始手把手搭建一个项目。</p>
<h2 id="init"><a href="#init" class="headerlink" title="init"></a>init</h2><pre><code class="bash"># 进入某个专门学习的文件夹
mkdir react-app &amp;&amp; cd react-app # 创建项目文件夹并进入
npm init -y # 快速创建package.json，跳过所有可选项
</code></pre>
<p>此时一个package.json文件已创建好，里面的可选配置后续再说。</p>
<p>在项目根目录下，再创建文件夹<code>config</code>作为webpack配置文件的存放，新建文件<code>webpack.config.js</code>，我们要开始配置啦。</p>
<pre><code class="bash"># 下载模块
yarn add webpack webpack-cli
# 个人喜欢使用yarn，也可用npm</code></pre>
<h2 id="mode"><a href="#mode" class="headerlink" title="mode"></a>mode</h2><p>mode一项配置很简单也很重要，作为开发环境的判断，可选择为<code>development</code>或<code>production</code>，并根据不同的环境参数，配置不同的webpack优化。</p>
<pre><code class="js">// webpack.config.js
module.exports = {
  mode: &#39;production&#39;
}</code></pre>
<p>webpack中若无mode配置，也可在package.json的scripts中配置mode参数</p>
<pre><code class="json">// pakeage.json
{
  &quot;scripts&quot;: {
    &quot;build&quot;: &quot;webpack --config=config/webpack.config.js --mode=production&quot;
  }
}</code></pre>
<p>到package.json这里就有人看不懂了<br>”哎？这里还能配置吗？我怎么看不懂啊？这是什么意思啊？“<br><del>好看的妹子请加微信求助私人辅导</del><br>咳咳，这里我将<code>npm init -y</code>创建的项目默认脚本命令删除了(test: echo什么的)。<br>创建了新的命令 名为<code>build</code>，其后的命令为<code>[启动的服务] --[参数名]=[参数值]</code></p>
<p>我们使用webpack的服务，配置其脚本地址(以package.json文件为根路径)，及mode环境。<br>之后再终端键入<code>npm run build</code>或<code>yarn build</code>即可启动打包命令</p>
<p>这里统一设置为生产环境。</p>
<h2 id="entry"><a href="#entry" class="headerlink" title="entry"></a>entry</h2><p>打包文件的入口，使用<code>path.resolve(__dirname, [path])</code>将文件相对路径转为绝对路径，基本配置如下：</p>
<pre><code class="js">const path = require(&#39;path&#39;)

module.exports = {
  entry: path.resolve(__dirname, &#39;./index.js&#39;)
}</code></pre>
<p>由于开发插件的特殊性，需要配置成多入口：</p>
<pre><code class="js">module.exports = {
  entry: {
    // 入口文件自定义name: 路径
    popup: path.resolve(__dirname, &#39;./popup.js&#39;),
    background: path.resolve(__dirname, &#39;./background.js&#39;),
    contentScript: path.resolve(__dirname, &#39;./contentScript.js&#39;),
  }
}</code></pre>
<h2 id="output"><a href="#output" class="headerlink" title="output"></a>output</h2><p>入口文件打包后的输出地址</p>
<pre><code class="js">module.exports = {
  output: {
    path: path.resolve(__dirname, &#39;../dist&#39;),
    //  【name】使用entry配置的自定义name作为文件名，这里将输出到/dist/static/js/文件夹下
    filename: &#39;static/js/[name].js&#39;,
    // 根据上条filename的配置，决定了其chunkFilename的名称
    // bundle即是打包过程中所使用的模块合并后的产物
    chunkFilename: &#39;static/js/[name].bundle.js&#39;,
  }
}</code></pre>
<h2 id="module"><a href="#module" class="headerlink" title="module"></a>module</h2><p>module？不是loader吗，我这么大一个loader去哪了？<br>module便是用来配置不同类型的loader。<br>我们能配置什么呢？</p>
<h3 id="js-jsx"><a href="#js-jsx" class="headerlink" title="js/jsx"></a>js/jsx</h3><p>使用react，必不可少的就是jsx语法和es678…等等可能会用到的高级语法，所以需要用到babel模块将其转换为es5。</p>
<pre><code class="bash">yarn add babel-loader @babel/core @babel/plugin-proposal-class-properties @babel/plugin-transform-runtime @babel/preset-env @babel/preset-react</code></pre>
<ul>
<li><code>@babel/preset-env</code> 指定babel可以转化最新的js语法，而无需微观管理目标环境所需语法</li>
<li><code>@babel/preset-react</code> 使用jsx语法必不可少的模块</li>
<li><code>@babel/plugin-proposal-class-properties</code>  顾名思义是用于js class语法的转换</li>
<li><code>@babel/plugin-transform-runtime</code> 为自己的代码创造一个沙盒环境，因为<code>core-js</code>会对全局范围的内置对象进行编译，如：定义与规范不一致的 Promise 对象，core-js可能会覆盖自己定义的对象，@babel/plugin-transform-runtime模块就是将内置对象使用模块引入的方式，避免对全局作用域的污染</li>
</ul>
<p>下载完babel模块后，配置规则</p>
<pre><code class="js">module.exports = {
  module: {
    rules: [
      {
        test: /\.js(x)?$/,
        exclude: /node_modules/,
        use: [
          {
            loader: &quot;babel-loader&quot;,
            options: {
              presets: [&quot;@babel/preset-env&quot;, &quot;@babel/preset-react&quot;],
              plugins: [&quot;@babel/plugin-transform-runtime&quot;],
            },
          },
        ],
      }
    ]
  }
}</code></pre>
<h3 id="css预处理"><a href="#css预处理" class="headerlink" title="css预处理"></a>css预处理</h3><p>根据个人口味选择loader，这里是scss</p>
<pre><code class="bash">yarn add style-loader css-loader postcss-loader sass-loader node-sass</code></pre>
<blockquote>
<p>node-sass 可是太tm慢了</p>
</blockquote>
<pre><code class="js">module.exports = {
  module: {
    rules: [
      {
        test: /\.(sc|c)ss?$/,
        use: [
          &quot;style-loader&quot;,
          &quot;css-loader&quot;,
          {
            loader: &quot;postcss-loader&quot;,
            options: {
              plugins: (loader) =&gt; [
                require(&quot;postcss-import&quot;)({ root: loader.resourcePath }),
              ],
            },
          },
          &quot;sass-loader&quot;,
        ],
      },
    ]
  }
}</code></pre>
<h3 id="img图片"><a href="#img图片" class="headerlink" title="img图片"></a>img图片</h3><p>安装<code>url-loader</code>&amp;<code>file-loader</code>，对代码中引用限制大小后的图片，做转base64处理，减少请求</p>
<pre><code class="js">module.exports = {
  module: {
    rules: [
      {
        test: /\.(gif|png|jpeg|jpg|svg)(\?t=\d+)?$/,
        use: [
          {
            loader: &quot;url-loader&quot;,
            options: {
              outputPath: &quot;static/images/&quot;,
              limit: 10 * 1024,
            },
          },
        ],
      }
    ]
  }
}</code></pre>
<h2 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h2><h3 id="html-webpack-plugin"><a href="#html-webpack-plugin" class="headerlink" title="html-webpack-plugin"></a>html-webpack-plugin</h3><p>此插件可根据入口文件生成一个html并引入js，或将js引入到自己配置的模板html中。</p>
<pre><code class="js">// 根据多页面的场景，将生成页面单独提出来，这样好看
// moreTemplate.js
const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);
const chunkNames = [
  { chunk: &#39;popup&#39;, name: &#39;前置弹窗页&#39; },
  { chunk: &#39;background&#39;, name: &#39;后置背景页&#39; },
];

module.exports = chunkNames.map(
  ({ chunk, name }) =&gt;
    new HtmlWebpackPlugin({
      title: name,
      filename: `${chunk}.html`,
      template: `public/index.html`,
      chunks: [&quot;vendor&quot;, chunk],
      chunksSortMode: &quot;manual&quot;,
    })
);

// webpack.config.js
const templateList = require(&quot;./moreTemplate&quot;);

module.exports = {
  plugins: [
    ...templateList,
  ]
}</code></pre>
<h3 id="uglifyjs-webpack-plugin"><a href="#uglifyjs-webpack-plugin" class="headerlink" title="uglifyjs-webpack-plugin"></a>uglifyjs-webpack-plugin</h3><p>压缩代码的插件，这没啥说的</p>
<pre><code class="js">const UglifyJsPlugin = require(&quot;uglifyjs-webpack-plugin&quot;);

new UglifyJsPlugin({
  test: /\.(js|jsx)/,
  exclude: /node_modules/,
  parallel: true,
  sourceMap: true,
}),</code></pre>
<h3 id="merge-jsons-webpack-plugin"><a href="#merge-jsons-webpack-plugin" class="headerlink" title="merge-jsons-webpack-plugin"></a>merge-jsons-webpack-plugin</h3><p>由于插件需要做国际化，在各模块中分别加入了其对应的message.json，使用此插件用于打包合并国际化的json</p>
<pre><code class="js">// 别问为什么抽出来，好看
// mergeLocale.js
const locales = [&quot;en&quot;,&quot;zh_CN&quot;,&quot;zh_TW&quot;]
/**
 * pattern: 以项目根路径的相对路径，获取json文件拼接
 * fileName: 填入output.publicPath的相对路径
 */
module.exports = locales.map((lang) =&gt; ({
    pattern: `{./src/_locales/${lang}/messages.json,./src/**/_locales/${lang}/messages.json}`,
    fileName: `./_locales/${lang}/messages.json`,
}));

// webpack.config.js
const MergeJsonWebpackPlugin = require(&quot;merge-jsons-webpack-plugin&quot;);
const MergeLocale = require(&quot;./mergeLocale&quot;);
new MergeJsonWebpackPlugin({
  debug: true,
  output: {
    groupBy: [...MergeLocale],
  },
}),</code></pre>
<h2 id="optimization"><a href="#optimization" class="headerlink" title="optimization"></a>optimization</h2><p>webpack中自带可配置的打包可重用模块代码分离优化功能</p>
<pre><code class="js">module.exports = {
  optimization: {
    usedExports: true, //  tree shaking 只支持import引入
    splitChunks: {
      minChunks: 1, //  需要拆分模块的最小引入次数
      chunks: &quot;all&quot;,  //  选择分离的区域
      cacheGroups: {  //  缓存组设置
        vendor: {
          name: &quot;vendor&quot;, //  分离出名为vendor的js，即chunkFilename中的name
          test: /[\\/]node_modules[\\/]/,
          priority: -10,
        },
      },
    },
  },
}</code></pre>
<h2 id="prod-amp-watch"><a href="#prod-amp-watch" class="headerlink" title="prod &amp; watch"></a>prod &amp; watch</h2><p>根据业务需求，又新建两个文件，watch开发用，prod打包用</p>
<pre><code class="js">// webpack.watch.js
const merge = require(&quot;webpack-merge&quot;);
const config = require(&quot;./webpack.base&quot;);

module.exports = merge(config, {
  watch: true,
  watchOptions: {
    aggregateTimeout: 1000, // milliseconds
    poll: 1000,
    ignored: [&quot;node_modules&quot;],
  },
});</code></pre>
<pre><code class="js">// webpack.prod.js
const merge = require(&quot;webpack-merge&quot;);
const { CleanWebpackPlugin } = require(&quot;clean-webpack-plugin&quot;);
const VersionList = require(&quot;./syncVersion&quot;);
const config = require(&quot;./webpack.base&quot;);

module.exports = merge(config, {
    plugins: [
        ...VersionList,
        new CleanWebpackPlugin(),
    ],
});</code></pre>
<p>哎注意细节，这里我又加入一个versionList，这干嘛的呢？<br>没有错，是用来同步插件版本号</p>
<pre><code class="js">const version = require(&quot;../src/config.json&quot;).version; 
const WriteJsonWebpackPlugin = require(&quot;write-json-webpack-plugin&quot;);
let package = require(&quot;../package.json&quot;);
let manifest = require(&quot;../public/manifest.json&quot;);

package.version = manifest.version = version;

const list = [
    { origin: &quot;../&quot;, filename: &quot;package.json&quot;, json: package },
    { origin: &quot;../public&quot;, filename: &quot;manifest.json&quot;, json: manifest },
    { origin: &quot;../dist&quot;, filename: &quot;manifest.json&quot;, json: manifest },
];

module.exports = list.map(
    ({ origin, filename, json }) =&gt;
        new WriteJsonWebpackPlugin({
            pretty: true,
            object: json,
            path: origin,
            filename,
        })
);</code></pre>
<p>这里抽离了版本号和国际化的所需国际语言数组<code>config</code>方便个人配置。</p>
<pre><code class="json">// package.json
{
  &quot;scripts&quot;: {
    &quot;watch&quot;: &quot;webpack --config=config/webpack.watch.js&quot;,
    &quot;build&quot;: &quot;webpack --config=config/webpack.prod.js&quot;,
  },
}</code></pre>
<p>到这里一个不使用devServer的chrome插件项目的配置就已经完成了，具体的代码文件，请移步到<a href="https://github.com/elegantYU/color-picker" target="_blank" rel="noopener">这里</a>欣赏(本身不想开源的，毕竟是个完整的产品，不过为了学习交流还是open了)<br>感觉不错的请不要怜惜我，狠狠地star吧！</p>
<blockquote>
<p>下章说下插件的开发流程，及我的插件架构思路，嘤嘤</p>
</blockquote>

      </div>

      <div class="article-footer">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%B8%80%E5%88%86%E9%92%9F%E6%95%99%E7%A8%8B/" rel="tag">#一分钟教程</a></li></ul>
      </div>

      <div class="article-navs">
        
<nav class="card-container card-article-nav">
  <div class="card-wrap">
    
      <div id="article-nav-newer" class="card-item img">
        <article>
          
            <div class="card-cover" style="background-image: url(https://i.loli.net/2020/06/14/dzpQ4PZVXuJMAmD.jpg)"></div>
          
          <a class="card-link article-nav-link" href="/2020/06/13/wallpagerShare2006/"></a>
          <strong class="article-nav-caption">Newer</strong>
          <p class="article-nav-title">
            
              私人珍藏大放送
            
          </p>
        </article>
      </div>
    
    
      <div id="article-nav-older" class="card-item img">
        <article>
          
            <div class="card-cover" style="background-image: url(https://i.loli.net/2020/05/11/QHhbWkXqM6Jp3Bv.png)"></div>
          
          <a class="card-link article-nav-link" href="/2020/05/11/git-commit-am/"></a>
          <strong class="article-nav-caption">Older</strong>
          <p class="article-nav-title">
            
              commit -am的正确姿势
            
          </p>
        </article>
      </div>
    
  </div>
</nav>

      </div>
      
      

  
  
  <div class="valine-container">
    <div id="valine_thread" class="valine-thread"></div>
  </div>
  

  
  


    </div>
  </article>
</div>

    <!-- footer container -->
<footer id="footer" class="footer">
  <div class="footer-container">
    <p>&copy; 2022 <a href="/" target="_blank">elegantYU</a></p>

    
      <p id="hitokoto"></p>
      <script src="https://v1.hitokoto.cn/?c=d&amp;encode=js&select=%23hitokoto" defer></script>
    

    

    <!-- <p>Powered by <a href="https://hexo.io" target="_blank">Hexo</a> Theme - <a href="https://github.com/miiiku/flex-block" target="_blank">flex-block</a></p> -->
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <div class="hiddenBox" style="display: none;">
      <span id="busuanzi_value_site_uv"></span>位道友拜访过
      <span id="busuanzi_value_site_pv"></span>次流连忘返
      <span id="busuanzi_value_page_pv"></span>次留名
      <span id="busuanzi_container_site_uv"></span>
      <span id="busuanzi_container_site_pv"></span>
      <span id="busuanzi_container_page_pv"></span>
    </div>
  </div>
</footer>
  </div>

  
  
<!-- valine 评论 start -->
<script type="text/javascript" src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script type="text/javascript" src='//unpkg.com/valine/dist/Valine.min.js'></script>
<script type="text/javascript">
  new Valine({
    el: "#valine_thread",
    appId: "5xXAw8mGSxsiAVvItnDTlc1Q-gzGzoHsz",
    appKey: "izanFwv9WmbM99bQQKMDt6jj",
    avatar: "elegantYu",
    placeholder: "我卢本伟！没有开挂！",
    notify: true,
    visitor: true,
    pageSize: 10,
  });
</script>
<!-- valine 评论 end -->



  <!-- aplayer 音频 start -->
  <link rel="stylesheet" href="/lib/APlayer.min.css">
  <script src="/lib/APlayer.min.js"></script>
  <script type="text/javascript">
    const aplayer = document.querySelectorAll(".aplayer");
    aplayer && initaplayer(aplayer);
    function initaplayer(els) {
      let elsArr = Array.from(els);
      elsArr.forEach(el => {
        new APlayer({
          container: el,
          audio: { ...el.dataset },
          theme: "#b7daff",
          lrcType: 3,
          autoplay: false,
          loop: false,
          mutex: true,
        });
      });
    }
  </script>
  <!-- aplayer 音频 end -->
  

<!-- dplayer 视频 start -->
<link rel="stylesheet" href="/lib/DPlayer.min.css">
<script src="/lib/DPlayer.min.js"></script>
<script type="text/javascript">
  const dplayer = document.querySelectorAll(".dplayer");
  dplayer && initDPlayer(dplayer);
  function initDPlayer(els) {
    let elsArr = Array.from(els);
    elsArr.forEach(el => {
      let url = el.dataset.url;
      let cover = el.dataset.cover;
      new DPlayer({
        container: el,
        video: { url: url, pic: cover },
        theme: "#b7daff",
        autoplay: false,
        loop: false,
        mutex: true,
      });
    });
  }
</script>
<!-- dplayer 视频 end -->


<!-- waterfall 瀑布流 start -->
<script src="/lib/waterfall.min.js"></script>
<script type="text/javascript">

const waterfalls = document.querySelectorAll(".waterfall-container");

if (waterfalls && waterfalls.length > 0) {
  waterfalls.forEach((waterfall, index) => {
    let cls = "waterfall-container-" + index;
    waterfall.classList.add(cls);
    initWaterfall(cls, waterfall);
  });
}

function initWaterfall(selector, el) {
  const options = {};
  if (Object.keys(el.dataset).length > 0) {
    for (let k in el.dataset) {
      options[k] = el.dataset[k];
    }
  }
  waterfall(`.${selector}`, options);
}
</script>
<!-- waterfall 瀑布流 end -->


  <!-- zoom start -->
  <script src="/lib/zoom.min.js"></script>
  <script type="text/javascript">
    document.querySelector(".article-content") && zoom(".article-content");
  </script>
  <!-- zoom end -->
  



  


  <!-- Google Analytics START -->
  <script type="text/javascript">
    (function (i, s, o, g, r, a, m) {
      if (window.location.hostname === "localhost" || window.location.hostname.startsWith("192.168")) {
        return console.log("本地调试");
      }
      i['GoogleAnalyticsObject'] = r; i[r] = i[r] || function () {
        (i[r].q = i[r].q || []).push(arguments)
      }, i[r].l = 1 * new Date(); a = s.createElement(o),
        m = s.getElementsByTagName(o)[0]; a.async = 1; a.src = g; m.parentNode.insertBefore(a, m)
    })(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga');
  
    ga('create', 'UA-165699409-1', 'auto');
    ga('send', 'pageview');
  </script>
  <!-- Google Analytics End -->

  


  



<script src="/js/script.js"></script>

<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@latest/build/highlight.min.js"></script>
<script>
  hljs.initHighlightingOnLoad();
</script>
  
  <!-- 尾部用户自定义相关内容 -->

<script async>window.onload=function(){var a=document.createElement('script'),b=document.getElementsByTagName('script')[0];a.type='text/javascript',a.async=!0,a.src='/sw-register.js?v='+Date.now(),b.parentNode.insertBefore(a,b)};</script></body></html>