<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>关于git的几件小事</title>
      <link href="/2021/10/24/team-git/"/>
      <url>/2021/10/24/team-git/</url>
      
        <content type="html"><![CDATA[<h1 id="认识工作流"><a href="#认识工作流" class="headerlink" title="认识工作流"></a>认识工作流</h1><p>git工作流，即 git 仓库单人/多人操作时所遵守的一种流程模式。</p><p>常见的工作流分支</p><table><thead><tr><th align="left">分支</th><th align="left">功能</th></tr></thead><tbody><tr><td align="left">master</td><td align="left">主干分支，一般用于集合所有发布版本</td></tr><tr><td align="left">develop/dev</td><td align="left">开发分支，用户集合所有在开发中的版本</td></tr><tr><td align="left">release</td><td align="left">待发布版本分支，集合当前版本所有需求</td></tr><tr><td align="left">feature</td><td align="left">每个需求需要在自己的 featrure 分支中开发</td></tr><tr><td align="left">hotfix</td><td align="left">来自发布后出现的 bug 需要从 master 拉取 hotfix 分支进行修复，修复完毕合并回 master 与 develop 分支</td></tr></tbody></table><h2 id="公司现有的工作流分析"><a href="#公司现有的工作流分析" class="headerlink" title="公司现有的工作流分析"></a>公司现有的工作流分析</h2><ol><li><p>小程序项目</p><p>小程序项目现有的工作流程较为明确</p><ul><li>[master] 分支负责集合发布 release 分支，堡垒环境测试通过后可直接上线</li><li>[release + 发布日期] 分支作为每个版本的需求集合分支，堡垒及之前的测试环境都可使用</li><li>[featrue] 分支暂时没有统一分支格式，单个需求开发，开发完毕后合并到 release 分支</li><li>[hotfix] 分支暂时没有统一分支格式</li></ul></li><li><p>h5 项目</p><p>h5 页面项目工作流理解简单，只有 master 和 feature 的分支配合</p></li><li><p>更简单的个人负责的项目</p><p>一条 master 分支搞定一切</p></li></ol><h1 id="多人合作中应注意到的事情"><a href="#多人合作中应注意到的事情" class="headerlink" title="多人合作中应注意到的事情"></a>多人合作中应注意到的事情</h1><p>多人项目做多了，会暴露很多问题，有些人可能注意到但工作完就忘记，有些是埋头开发不管其他</p><h2 id="branch-命名"><a href="#branch-命名" class="headerlink" title="branch 命名"></a>branch 命名</h2><p>  这里主要提及的就是 feature 和 hotfix 的分支命名，由于缺少命名规范，大家对命名都有自己的理解，eg: 弱引导需求</p><pre><code>    1. feat-weakGuide    2. feature-weakGuide    3. feat/weakGuide    4. feat_weakGuide     5. weak-guide</code></pre><p>  个人目前使用 1 的格式，前前东家内的格式为<code>[分支类型]-[发布版本]-[功能名]</code>进行约束，查看 branch list 会直观查询到自己寻找的分支</p><pre><code>    feat-0930-xxxx    feat-1028-weakGuide    feat-1030-yyyy</code></pre><p>  当然，搭配成团队适合，大家都能接受的规范才是好规范</p><h2 id="commit-规范"><a href="#commit-规范" class="headerlink" title="commit 规范"></a>commit 规范</h2><p>  建议直接看阮一峰的 <a href="https://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html" target="_blank" rel="noopener">commit message 与 change log</a>，这里简单介绍下 commit message 的 header 部分</p><p>  header 就是我们常用的 commitlog，<code>git commit -m &#39;这里是 header&#39;</code></p><p>  header 规范由三个部分组成 <code>[type]([scope]): [subject]</code> ，例如</p><pre><code class="bash">  git commit -m &#39;feat(robShare): 新增任意行活动入口;样式优化;bug修复&#39;</code></pre><ul><li><p>type 类型</p><p>一般为以下几种类型</p><table><thead><tr><th align="left">名称</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">feat</td><td align="left">新功能/需求(feature)</td></tr><tr><td align="left">fix</td><td align="left">修复了 bug</td></tr><tr><td align="left">style</td><td align="left">样式调整，不影响代码逻辑</td></tr><tr><td align="left">pref</td><td align="left">优化，可能是代码格式化，或代码优化</td></tr><tr><td align="left">docs</td><td align="left">文档</td></tr><tr><td align="left">…</td><td align="left">…</td></tr></tbody></table></li><li><p>scope 范围</p><p>这是个可选项，用于方便代码审查时直观了解到这个 commit 的作用范围</p><p>比如，这次需求主要在 robShare 页面里的修改，但只看 subject 不能直接了解到是哪个文件夹/页面，这时， scope 就是很有必要的</p><pre><code>fix(common/util): xxx工具函数调整</code></pre></li><li><p>subject</p><p>这就没什么具体的规范了，已直观、概括为主，可用分号隔离不同的描述</p></li></ul><h2 id="commit-message-的客户端工具"><a href="#commit-message-的客户端工具" class="headerlink" title="commit message 的客户端工具"></a>commit message 的客户端工具</h2><p>  网上有很多对于提交信息的约束工具，我的个人项目一般都是用 <code>husky + commitlint</code></p><ul><li><a href="https://github.com/typicode/husky" target="_blank" rel="noopener">husky</a> 是一个 githook工具，在 package.json 中配置 git hooks 用于处理各个阶段的问题</li><li><a href="https://github.com/conventional-changelog/commitlint" target="_blank" rel="noopener">commitlint</a> 用于 commit message 的格式校验</li></ul><p>  简单配置如下：</p><p>  package.json</p><pre><code class="json">  &quot;husky&quot;: {        &quot;hooks&quot;: {            &quot;commit-msg&quot;: &quot;commitlint --config .commitlintrc.js -E HUSKY_GIT_PARAMS&quot;        }    }</code></pre><p>  commitlintrc.js</p><pre><code class="js">  module.exports = {    extends: [&#39;@commitlint/config-conventional&#39;],    rules: {      &#39;type-enum&#39;: [        2,        &#39;always&#39;,        [&#39;build&#39;, &#39;ci&#39;, &#39;chore&#39;, &#39;feat&#39;, &#39;docs&#39;, &#39;fix&#39;, &#39;perf&#39;, &#39;refactor&#39;, &#39;style&#39;, &#39;notes&#39;, &#39;wip&#39;, &#39;version&#39;],      ],    },  };</code></pre><h1 id="git操作-常见-可能-会遇到的问题"><a href="#git操作-常见-可能-会遇到的问题" class="headerlink" title="git操作 常见/可能 会遇到的问题"></a>git操作 常见/可能 会遇到的问题</h1><ol><li><p>git add 后想撤销</p><p> 编辑器的 git 控制台可以操作撤回，或者使用 <code>git reset HEAD</code>命令</p></li><li><p>git commit 后想撤回</p><ul><li>找到想撤回的 commitid，获取其前一版本的 commitid</li><li><code>git reset --hard &lt;commitid&gt;</code></li></ul></li><li><p>git commmit 后发现开发的分支错了</p><ul><li>获取这次修改提交的 commitid</li><li>切换到需要正确的分支</li><li><code>git cherry-pick &lt;commitid&gt;</code></li><li>可以转移多个提交 <code>git cherry-pick &lt;commitid A&gt; &lt;commitid B&gt;</code></li></ul></li><li><p>压缩本地开发的 commit</p><p>本地开发可能由于各种情况，会出现一个分支有多个无用的 commit</p><pre><code class="bash"> hash a   wip: 没写完 hash b   wip: 还没写完 hash c   wip: 就快写完了</code></pre><p>如果当前分支直接合并在 release 上，会使得分支树 log 很多，并且代码审核时很费劲，尽量保证每次合并分支，只有一次有效 commit。</p><p>所以我们需要对本地的 commmit 进行压缩</p><pre><code class="bash"> git rebase -i &lt;commitid c&gt; ----- 会出现以下场景 pick [hash a] wip: 没写完 pick [hash b] wip: 还没写完 pick [hash c] wip: 就快写完了 ----- 除了顶部第一个 commit 不修改之外，剩下的 pick 改为 squash | s pick [hash a] wip: 没写完 s [hash b] wip: 还没写完 s [hash c] wip: 就快写完了 ----- 保存退出后，需要填写压缩后的 commit message，修改后保存退出</code></pre><p>如此就合并了许多无特殊意义的 commit</p></li><li><p>压缩后后悔了，怎么撤销</p><p> 这里要了解下 <code>git reflog</code> 可以查看 git 的所有操作记录，其内所有的 commitid 都是可以进行回滚的</p></li><li><p>分支重命名</p><p> 在需要改名的分支下 <code>git branch -m &lt;newname&gt;</code></p></li><li><p>修改 commit message</p><p> <code>git commit --amend</code></p></li></ol><p>…</p><p>以上都是为了方便团队协同和提升个人开发规范性，各种命令若是有 GUI 可以替代的话，可以选择自己更方便的操作。</p>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>里程</title>
      <link href="/2021/09/05/first-in-ctrip/"/>
      <url>/2021/09/05/first-in-ctrip/</url>
      
        <content type="html"><![CDATA[<blockquote><p>沪漂挣扎四余载，今朝始见灯塔明</p></blockquote><h2 id="起点"><a href="#起点" class="headerlink" title="起点"></a>起点</h2><p>初入社会时，啥都不懂。不懂得选择公司，不懂得了解业务，不懂得未来发展等等。</p><p>这种种的不懂，让我前两年一直处于混沌迷茫之中，公司住所两点一线，整日机械化的处理工作埋头搬砖，下班也没有能让我感兴趣的人和事，真真正正的体验到何为码农。</p><p>我开始厌倦和畏惧这种生活，我极力想去改变它，于是从第二家公司离职了。</p><p>离开了妹子颇多，但感觉找不到快乐的公司。当时和主管谈为什么要走，我说是技术环境和薪资不行，并且说了一个远不符合当前技术的价位，以求快速脱离苦海。我其实很清楚自己技术水平，虽然公司的高压下，学到了很多，但都是应急的知识的皮毛，这种水准，在上海前端里一捞一大片。</p><p>不逼自己一把，不知道自己还有多少潜力。</p><h2 id="拐点"><a href="#拐点" class="headerlink" title="拐点"></a>拐点</h2><p>技术水准和言语表达能力差的情况下，果不其然，连连碰壁。</p><p>大概一个多月的面试时光，对自己的目标定位逐渐悲观“大公司 -&gt; 技术环境好 -&gt; 钱给够 -&gt; 小公司 -&gt; 有公司要就行”，麻木之际，终于收到一家创业公司的 offer，我立即结束了对自己人性的考验。</p><p>松江到浦东很远，可是我不在乎，在技术和头脑没有优势的情况下，吃苦耐劳是我为数不多的长处了。</p><p>这家公司算是我第一次踏入上海互联网行业，创业公司，人不多，但员工内聚氛围好；开发加我就三位，但是大家畅所欲言，互相学习。这种场景是我进社会前所期待的，我也十分珍惜这家公司(准备呆到合同结束是我最大的温柔)。</p><p>开放包容成长的氛围，真的很重要，尤其是成长。我从一个听之任之的码农，慢慢蜕变成有点思想的工程师，就是从这里开始。</p><hr><p>刚开始</p><p>产品：这次需求有什么看法和建议吗。</p><p>同事：有几点我觉得有些问题…balabla</p><p>我：…我都行，听你的</p><p>–</p><p>后来</p><p>产品：这次需求就是这些..</p><p>我：我感觉这些地方可以优化一下..balabala</p><p>同事：我也是这样想</p><hr><p>和一帮有自己想法的人工作，实在是太舒服了，打通了我闭塞的神经，拓宽了思路和见地，每天都能切实的感觉到自己思维方面在慢慢进步。</p><p>天下无不散的筵席，终究还是说拜拜 👋🏻。</p><h2 id="沉淀"><a href="#沉淀" class="headerlink" title="沉淀"></a>沉淀</h2><p>入职了一家传统企业，主要还是看中了名头和离住所的距离，两周后看清了，这不就和第二家公司一样，技术技术不行，项目全看老板。</p><p>这种环境中我一度想要离职，哪怕再换到小公司。可转眼再看，朝九晚五，平常一天没多少事，为什么不能在这里摸摸鱼沉淀自己呢。我抱着随时离职的心态，在这家公司慢慢积累着能量。</p><p>这家公司学到的对我个人来说重要的一点，就是认清了自己能力在市场的价位。</p><p>在了解到同事的技术水平和薪资后，我心态瞬间轻松，这技术水平，价位这么高，那我岂不是可以更高？</p><p>不负我望，在之后的面试过程中，自我感觉表现的都很自如，哪怕我技术不如你，但我心态依旧很好。</p><h2 id="准备起飞"><a href="#准备起飞" class="headerlink" title="准备起飞"></a>准备起飞</h2><p>四年工作，我深深体会到个人思想和实际行动的重要性，在踏实做事学习的基础上，若我能提前两年开拓我的思维方式和规划方向，那绝不止现在这点成就。</p><p>这也是我和别人聊天交谈会先观察了解他人的思想高度的原因，真的太重要了。</p><p>进入国内也算一线的大厂，同事们交流氛围都挺好，更符合我心中大厂期望的是项目开发流程的细化。</p><p>之前中小企业是一个人画图纸，然后大刀阔斧砍树造房子。</p><p>这里则不同，画图纸、砍树、造房子、装修、维护细节到每一颗螺丝钉都会有细化的分工。所谓面试造火箭，进厂拧螺丝，是要你有能造火箭的全局思维，这样拧起螺丝来会更有效率。</p><p>然后是方法论及问题概念的抽象，在人数优势下，大家对问题的处理方式，思考过程，思考思考的过程会被一步步抽象出来，完善成一个个有效的场景方法论。</p><p>这种思考过程会被文档记录下来，实在太好了。</p><blockquote><p>保持进步，持续学习</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-爬楼梯</title>
      <link href="/2021/08/12/algorithm-climbStairs/"/>
      <url>/2021/08/12/algorithm-climbStairs/</url>
      
        <content type="html"><![CDATA[<p>随缘刷，不计时</p><a id="more"></a><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>爬楼梯，每次只能爬一阶或两阶，问 n 阶楼梯有多少种爬法？</p><pre><code class="js">例： 2 阶解： 1 + 1; 2. 两种例：3 阶解：1 + 1 + 1； 2 + 1； 1 + 2. 三种</code></pre><p><a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="noopener">原题传送门</a></p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>从这题开始，刷 dp！</p><p>动态规划一般用于大问题拆解成小问题求解，例如极值等等(好像基本都是极值)</p><p>这题同理可以将问题拆解下，找出通用公式</p><pre><code class="js">1 阶： 1 种2 阶： 2 种 | 1 + 1； 23 阶： 3 种 | 1 + 1 + 1； 2 + 1； 1 + 24 阶： 5 种 | 1+1+1+1；1+2+1；2+1+1；2+2...</code></pre><p>可以看到 第 n 阶的话，应该是 <code>n - 1</code> 和 <code>n - 2</code> 的解法之和(类似斐波那契)</p><p>得出此解</p><pre><code class="js">function climb (n) {  const dp = Array.from({ length: n })  for(let i = 0; i &lt; n; i++) {    if (i == 0 || i == 1) {      dp[i] = i + 1    } else {      dp[i] = dp[i - 1] + dp[i - 2]    }  }  return dp[n - 1]}</code></pre><blockquote><p>这和斐波那契一样 作为动态规划思想的入门是可以的</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-打印dom🌲</title>
      <link href="/2021/08/04/algorithm-printDomTree/"/>
      <url>/2021/08/04/algorithm-printDomTree/</url>
      
        <content type="html"><![CDATA[<p>DFS &amp;&amp; BFS</p><a id="more"></a><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>页面有如下 dom 标签，如何按照结构输出以下排列的标签名</p><pre><code class="js">dom: &lt;header&gt;  &lt;logo /&gt;  &lt;nav&gt;    &lt;ul&gt;      &lt;li /&gt;      &lt;li /&gt;      &lt;li /&gt;    &lt;/ul&gt;  &lt;/nav&gt;&lt;/header&gt;&lt;aside /&gt;&lt;section&gt;  &lt;article&gt;    &lt;div&gt;&lt;/div&gt;  &lt;/article&gt;&lt;/section&gt;输出: headerlogonavullililiasidesectionarticlediv</code></pre><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>根据 dom 结构和打印顺序，可以看到是深度优先遍历 DFS (deep first search)</p><p>获取标签名后输出，代码如下</p><pre><code class="js">function DFStree (root = document.body) {  const children = Array.from(root.children)  if (children.length) {    for(let i = 0; i &lt; children.length; i++) {      const el = children[i]      console.log(el.tagName)      DFStree(el)    }  }  return}</code></pre><blockquote><p>easy</p></blockquote><p>如果输出顺序改一下呢</p><pre><code class="js">headerasidesectionlogonavarticleuldivli</code></pre><p>即 BFS 广度优先遍历，how？</p><p>利用队列思想，将同层 dom 打印时，判断其是否有 children，若有则加入队列，等待下次打印</p><pre><code class="js">function BFStree(root = document.body) {  const list = []  const children = Array.from(root.children)  children.map(v =&gt; list.push(v))  let idx = 0  while(idx &lt; list.length) {    const el = list[idx]    const { tagName, className } = el    console.log(`${tagName} --- ${className}`)    if (el.children.length) {      list.push(...Array.from(el.children))    }    idx++  }}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-股票最大利润</title>
      <link href="/2021/08/04/algorithm-profit/"/>
      <url>/2021/08/04/algorithm-profit/</url>
      
        <content type="html"><![CDATA[<p>谢特，每次三分钟热度的算法题</p><a id="more"></a><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？</p><p>示例1:</p><pre><code class="js">输入: [7,1,5,3,6,4]输出: 5解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。</code></pre><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">原题链接</a></p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ul><li>价格数组的顺序是固定的</li><li>买入卖出只能是 前面小 后面大</li><li>如果天数小于两天 或价格一直跌的话 则不赚钱</li></ul><p>根据前两条，我们可以先设置一个起点作为最小价格，之后遍历判断 当天价格是否小于初始最小价格，决定是否替换最小价格。</p><p>设置初始最高价格索引为 1(因为初始最低价索引是 0), 遍历时用 <code>arr[idx] - low</code> 获取最大值，每次最大值与之比较。</p><pre><code class="js">function maxProfit (prices) {  if (prices.length &lt; 2) return 0  let low = prices[0]  let profit = 0  let idx = 1  while (idx &lt; prices.length) {    profit = Math.max(prices[idx] - low, profit)    low = Math.min(prices[idx], low)    idx++  }  return profit}</code></pre><p>good!</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-两数相加链表</title>
      <link href="/2021/07/20/algorithm-sumTwoLink/"/>
      <url>/2021/07/20/algorithm-sumTwoLink/</url>
      
        <content type="html"><![CDATA[<p>第 7 天？</p><a id="more"></a><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。</p><p>例：</p><pre><code class="js">链表 1 -&gt; 4 -&gt; 3  &amp; 2 -&gt; 8 -&gt; 2输出 3 -&gt; 2 -&gt; 6341 + 282 = 623</code></pre><pre><code class="js">// 链表结构function ListNode(val, next) {    this.val = val === undefined ? 0 : val;    this.next = next === undefined ? null : next;}</code></pre><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>经过前面训练还用思考吗，直接冲</p><pre><code class="js">function addTwoNumbers(a, b) {  const res = new ListNode()    let temp = 0;    while (a || b || temp) {        const sum = a.val + b.val;        const [ten, bit] = sum.toString().padStart(2, &#39;0&#39;)        a &amp;&amp; a = a.next        b &amp;&amp; b = b.next    res.val = bit + temp    }}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-获取有序数组中最小的相同元素</title>
      <link href="/2021/07/19/algorithm-getMinEqualItem/"/>
      <url>/2021/07/19/algorithm-getMinEqualItem/</url>
      
        <content type="html"><![CDATA[<p>第六天</p><a id="more"></a><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>获取两个有序数组的最小相同元素</p><pre><code class="js">输入：[1,2,3,4,5], [3,4,5,6,7]输出：3</code></pre><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>递归？指针？暴力解？</p><p>指针，这是不一样的双指针，两个数组分别一个指针。</p><p>因为是有序数组，可以分别从头开始遍历(如果不是有序数组也要先排序)，a 若小于 b，a 指针进一位，大于情况同理。</p><p>若出现相同元素，遇到就返回</p><pre><code class="js">function getMinEqualItem(a, b) {    let i = 0,        j = 0;    while (i &lt; a.length || j &lt; b.length) {        if (a[i] === b[j]) {            return a[i];        } else if (a[i] &lt; b[j]) {            i++;        } else {            j++;        }    }    return null;}</code></pre><blockquote><p>简单有效 无敌</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-获取链表中间节点</title>
      <link href="/2021/07/16/algorithm-linkMiddleNode/"/>
      <url>/2021/07/16/algorithm-linkMiddleNode/</url>
      
        <content type="html"><![CDATA[<p>继续链表 双指针</p><a id="more"></a><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定链表，要求返回链表中间节点，若没有中间节点则返回 null</p><pre><code class="js">链表：[1,2,3,4,5,6,7]返回：4</code></pre><pre><code class="js">链表：[1,2,3,4,5,6]返回：null</code></pre><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>根据上一章，了解到快慢指针的思路来看这一题</p><ul><li>如果链表长度是奇数，则有中间节点，反之则无</li><li>快慢指针都从头节点开始遍历，每次遍历，慢指针走一位 a.next，快指针多走一位 b.next.next。</li><li>先从慢指针来看，每次走一步，走完 link 就是 n 步；再看快指针，每次距离都比上次 + 1，走完全程是 n / 2</li><li>而 b.next 为 null 是奇数，有中间节点；b.next.next 为 null 是偶数，无中间节点</li></ul><pre><code class="js">function middleNode(list) {    let slow = list;    let fast = list;    while (fast &amp;&amp; fast.next) {        slow = slow.next;        fast = fast.next.next;    }    return slow;}</code></pre><p>时间 O(n)</p><p>空间 O(1)</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-唤醒链表</title>
      <link href="/2021/07/16/algorithm-cycleLink/"/>
      <url>/2021/07/16/algorithm-cycleLink/</url>
      
        <content type="html"><![CDATA[<p>第五天</p><a id="more"></a><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个链表，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：<strong>pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</strong></p><p>如果链表中存在环，则返回 true 。 否则，返回 false 。</p><p>示例：</p><pre><code class="js">输入：head = [3,2,0,-4], pos = 1输出：true解释：链表中有一个环，其尾部连接到第二个节点。</code></pre><pre><code class="js">输入：head = [1,2], pos = 0输出：true解释：链表中有一个环，其尾部连接到第一个节点。</code></pre><pre><code class="js">输入：head = [1], pos = -1输出：false解释：链表中没有环。</code></pre><p><a href="https://leetcode-cn.com/problems/linked-list-cycle/submissions/" target="_blank" rel="noopener">原题传送门</a></p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>给出一个链表，要求判断是否存在循环的链表，题目给出的 pos 是帮助理解题意，并非是传入条件。</p><ol><li>使用 map 存储递归的每个节点，并判断</li></ol><ul><li>递归内容：判断 map 中是否存在此节点</li><li>返回条件： 参数 link 为 null，或者 map 中存在此节点的下个节点</li><li>返回内容： 返回 link.next 继续执行</li></ul><pre><code class="js">function hasCycle(link, map = new Map()) {    if (!link) return false;    if (map.has(link.next)) {        return true;    } else {        map.set(link.next);    }    return hasCycle(link.next, map);}</code></pre><ol start="2"><li>快慢指针，标准解法</li></ol><p>快慢指针，设立慢指针指向 head，快指针指向 head.next。</p><p>开始循环时，快指针每次都要多走一步，快指针永远会比慢指针先走，若是遇到环形指针，则两者都会进入循环，由于快指针每次都多走一步，所以他俩终将相遇。</p><p>若是没有循环，则快指针会先触底。</p><p><strong>追及问题</strong></p><pre><code class="js">function hasCycle(link) {    let slow = link;    let fast = link.next;    while (!fast &amp;&amp; !fast.next) {        if (slow === fast) {            return true;        }        slow = slow.next;        fast = fast.next.next;    }    return false;}</code></pre><p>我哭了 空间复杂度 O(1)</p><p>牛逼</p><ol start="3"><li>神奇解法 JSON.stringify</li></ol><pre><code class="js">function hasCycle(link) {    try {        JSON.stringify(link);    } catch (e) {        return true;    }    return false;}</code></pre><blockquote><p>后面继续跟一题 获取链表中间节点的题 深化快慢指针的思路</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-合并两个有序链表</title>
      <link href="/2021/07/15/algorithm-mergeTwoLists/"/>
      <url>/2021/07/15/algorithm-mergeTwoLists/</url>
      
        <content type="html"><![CDATA[<p>第四天</p><a id="more"></a><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>合并两个有序链表</p><p>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p><pre><code class="js">输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</code></pre><p><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">原题传送门</a></p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>和昨日的链表部分思路是一致的，使用指针定位节点并比较</p><p>划掉！用个**指针！</p><p>递归，就直接递归！</p><p>根据题目获取条件</p><ul><li>有序链表，我们可以逐个比较</li><li>递归内容: link.val 比较，小的一方作为链表头拼接到 res 后</li><li>递归终止条件: 两个链表长度不定，其中一个链表 next === null 后结束</li><li>递归返回值: 返回比较后的两个链表</li></ul><pre><code class="js">function ListNode(val, next) {    this.val = val === undefined ? 0 : val;    this.next = next === undefined ? null : next;}</code></pre><pre><code class="js">function mergeTwoLists (l1, l2) {  if (l1 === null) return l2  if (l2 === null) return l1  if (l1.val &lt; l2.val) {    l1.next = mergeTwoLists(l1.next, l2)    return l1  } else {    l2.next = mergeTwoLists(l1, l2.next)    return l2  }}</code></pre><blockquote><p>记住递归算法要找出三个要点：递归停止条件、递归内容、递归返回值</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-射靶得分</title>
      <link href="/2021/07/15/algorithm-shootScore/"/>
      <url>/2021/07/15/algorithm-shootScore/</url>
      
        <content type="html"><![CDATA[<p>敢算法第四天</p><a id="more"></a><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>刷脉脉看到的一题(据说是字节面试题)</p><p>运动员射靶 10 次，每次得分区间 0 - 10 之间，问总分 90 分的情况有多少种</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>设计函数</p><pre><code class="ts">// 传入目标得分 输出情况type ShootScore = (target: number, times?: number) =&gt; number</code></pre><p>猛地一看，这不就排列组合嘛这不就，排列…是排列还是组合来的？</p><p>组合，对是组合(排列有序，组合无序。太丢人 学的都还回去了)</p><p>先暴力写一下，看看思路</p><pre><code class="js">function shootScore (target, times = 10) {  let sum = 0  for(let i = 0; i = 10; i++) {    for(let j = 0; j = 10; j++) {      ...n      {        if (i + j + ... + n === target) {          sum++        }      }    }  }  return sum}</code></pre><p>重复循环递归下</p><pre><code class="js">function shootScore (target, times = 10) {  let sum = 0  const recursive = (idx = 1, pre = 0) =&gt; {    for (let i = 0; i = 10; i++) {      if (idx &lt; times) {        idx++        recursive(idx, pre + 1)      } else {        if (pre === target) {          sum++        }      }    }  }  return sum}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-删除链表倒数第n个节点</title>
      <link href="/2021/07/14/algorithm-reomveNodeFromEnd/"/>
      <url>/2021/07/14/algorithm-reomveNodeFromEnd/</url>
      
        <content type="html"><![CDATA[<p>干算法第三天</p><a id="more"></a><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</p><p>你能尝试使用一趟扫描实现吗？</p><p>示例：</p><pre><code class="js">输入：head = [1,2,3,4,5], n = 2输出：[1,2,3,5]</code></pre><p>(原题传送门)[<a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/]" target="_blank" rel="noopener">https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/]</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>说实话，没有思路。</p><p>看了别人的思路，也很摸不到头脑，像是背后有答案的奥数题，看着答案抄能做出来，但是完全没有记忆点。</p><p>算了，不多 bb</p><h3 id="链表结构"><a href="#链表结构" class="headerlink" title="链表结构"></a>链表结构</h3><p>复习下链表结构</p><pre><code class="ts">interface ListNode {    value: number;    next: ListNode | null;}</code></pre><pre><code class="js">function ListNode(val, next) {    this.val = val === undefined ? 0 : val;    this.next = next === undefined ? null : next;}</code></pre><h3 id="如何删除链表节点"><a href="#如何删除链表节点" class="headerlink" title="如何删除链表节点"></a>如何删除链表节点</h3><p>例： 给出下面链表，删除 D <code>n = 3</code></p><pre><code class="js">A -&gt; B -&gt; C -&gt; D -&gt; E -&gt; F</code></pre><p>要先获取到 D 前面的节点 C , 方可 <code>C.next = C.next.next</code> 将 D 删除</p><h3 id="双指针-一点点数学"><a href="#双指针-一点点数学" class="headerlink" title="双指针 + 一点点数学"></a>双指针 + 一点点数学</h3><ul><li>扫描顺序从 A 开始，创建 curr 变量指向当前链表，创建 pre 变量也指向当前链表(都是初始链表)，扫描步数 <code>i = 1</code> 开始</li><li>开始扫描时，curr 一直走，当 curr 与 pre 的距离为 n 时(<code>步数大于 n</code>)，pre 也开始移动</li><li>当扫描到 curr 变量指向 End 节点时，当前的 pre 节点即为需要删除的节点的上级节点</li></ul><pre><code class="js">function removeNthFromEnd(list, n) {    // 加入了起点占位节点    let curr = list;    let pre = list;    let i = 1;    while (curr.next) {        if (i &gt; n) {            pre = pre.next;        }        curr = curr.next;        i++;    }    pre.next = pre.next.next;    return list.val;}</code></pre><blockquote><p>一定是长期做数学方面的人才能对数字这么敏感，想出这招吧…</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-z字形变换</title>
      <link href="/2021/07/13/algorithm-covertz/"/>
      <url>/2021/07/13/algorithm-covertz/</url>
      
        <content type="html"><![CDATA[<p>肝算法第一天</p><a id="more"></a><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行  Z 字形排列。</p><p>比如输入字符串为 “PAYPALISHIRING”  行数为 3 时，排列如下：</p><pre><code class="js">P   A   H   NA P L S I I GY   I   R</code></pre><p>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”PAHNAPLSIIGYIR”。</p><p>请你实现这个将字符串进行指定行数变换的函数：</p><pre><code class="js">convert(s, numRows);</code></pre><p>示例：</p><pre><code class="js">输入：s = &quot;PAYPALISHIRING&quot;, numRows = 3输出：&quot;PAHNAPLSIIGYIR&quot;</code></pre><p><a href="https://leetcode-cn.com/problems/zigzag-conversion/" target="_blank" rel="noopener">原题传送门</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="按照-z-形顺序查找"><a href="#按照-z-形顺序查找" class="headerlink" title="按照 z 形顺序查找"></a>按照 z 形顺序查找</h3><p>z 形图的行数 row 已知，我们可以创建 row 个数组来存放查到的元素 <code>[[], [], []]</code></p><p>然后该怎么查询元素呢</p><p>根据例子我们可以看到，如果按照 左上 -&gt; 左下 -&gt; 下列上 -&gt; 下列下 的顺序去读的话，和源字符串是一样的。</p><pre><code class="js">P   A   H   NA P L S I I GY   I   R</code></pre><p>又可以看到，这里每 4 个数是一个周期，之后的形态和顺序也都是一致的。</p><p>还是不好总结规律？那么再多看一个不同行数的例子 (4 行)</p><pre><code class="js">H     OE   W RL O   L !L     D</code></pre><p>这里的小周期是 6 个数</p><pre><code class="js">row = 3;cycle = 4;row = 4;cycle = 6;</code></pre><p>可以得到规律 <code>cycle = row + row - 2</code>, 即 <code>cycle = 2 * row - 2</code></p><hr><p>看到这里应该有个模糊的思路，这个解法和周期有关，但是循环 左上 -&gt; 左下 之后该怎么处理，才能把后面 <strong>数的索引</strong> 与 <strong>对应行数</strong> 关联呢</p><p>这里就有两种解法</p><ol><li>取余</li></ol><p>可以将循环 s 字符串的索引 i，与 cycle 周期取余 <code>remiander = i % cycle</code>，这个余数就是每个小周期内元素的位置</p><p>remainder(余数) 若小于 row， 则 s[i] 可以插入 res[i] 中；</p><p>大于或等于的条件，正是处于 左下 -&gt; 下列上 的路线里，而 <code>cycle - remainder</code> 就等于其对应的 res 的索引</p><p>代码如下</p><pre><code class="js">function convert(s, row) {    // 所有行数组    const res = Array.from(Array(row), () =&gt; Array(s.length));    const cycle = 2 * row - 2;    for (let i = 0, len = s.length; i &lt; len; i++) {        const remainder = i % cycle;        if (remainder &lt; cycle) {            res[remainder].push(s[i]);        } else {            res[cycle - remainder].push(s[i]);        }    }    return res.reduce((str, arr) =&gt; `${str}${arr.join(&quot;&quot;)}`, &quot;&quot;);}</code></pre><ol start="2"><li>flag 定义拐点</li></ol><p>这个解法也是很奇妙，逻辑死板的我是没想到，利用 flag 定义查找的方向和差值</p><p>主要是拐点判断的方式不同换汤不换药</p><pre><code class="js">function convert(s, row) {    const res = Array.from(Array(row), () =&gt; Array(s.length));    const cycle = 2 * row - 2;    let flag = -1;    let rowIdx = 0;    for (let i = 0, len = s.length; i &lt; len; i++) {        res[rowIdx].push(s[i]);        // 周期结束后 flag 取反， 左上 -&gt; 左下 flag 为 1； 左下 -&gt; 下列上 flag 为 -1        if (rowIdx === 0 || rowIdx === row - 1) {            flag = -flag;        }        // rowIdx 在左下 -&gt; 下列上的路线中，会再变为 0        rowIdx = rowIdx + flag;    }    return res.reduce((str, arr) =&gt; `${str}${arr.join(&quot;&quot;)}`, &quot;&quot;);}</code></pre><h3 id="按照结果顺序，逐行查找"><a href="#按照结果顺序，逐行查找" class="headerlink" title="按照结果顺序，逐行查找"></a>按照结果顺序，逐行查找</h3><p>这种解法是我刚开始的思路，<strong>获取每行的每列间的规律</strong>, 但是脑子里只有一个大概的想法，不能精简提炼出来。</p><pre><code class="js">这              服个          的  所解      真      以法  是          要  到我              嫖</code></pre><p>第一行和最后一行，每个元素间 index 的差值为 2 * row - 2</p><p>第 i 行，index 分别是</p><pre><code>1 7 92 6 103 5 11 13</code></pre><p>间距差值为</p><pre><code>6 24 42 6 2</code></pre><p>这与每行索引 i(1 | 2 | 3) 、 周期 cycle(8) 的联系是什么呢</p><pre><code>cycle - 2 * i   2 * icycle - 2 * i   2 * icycle - 2 * i   2 * i   cycle - 2 * i</code></pre><p>综上可以的规律：</p><ul><li>第一行与最后一行间距固定，为 2 * row - 2</li><li>第 i 行间距是两个值交替，2 _ row - 2 - 2 _ i || 2 * i</li><li>每行元素下标，不会超过 s 长度</li></ul><pre><code class="js">function convert(s, row) {    const cycle = 2 * row - 2; //  周期    let nextIdx = 0; //  每行下个元素的下标    let offset = 0; //  交替变化的元素间距    let res = &quot;&quot;;    for (let i = 0; i &lt; row; i++) {        // 下一行的起始 i        nextIdx = i;        offset = 2 * i;        while (nextIdx &lt; s.length) {            res += s[nextIdx];            // 这是最精巧的一步，offset会交替变为 2 * i 或 cycle - 2 * i            offset = cycle - offset;            // 当前行是第一行或最后一行            nextIdx += i === 0 || i === row - 1 ? step : offset;        }    }    return res;}</code></pre><p>最后一种解法很高效，无论空间和时间都远超上面解法，不过找规律这块真的把我搞住了，之后直接选择了第一种解法。</p><blockquote><p>希望面试别遇到</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-三数之和</title>
      <link href="/2021/07/12/algorithm-sumthreenum/"/>
      <url>/2021/07/12/algorithm-sumthreenum/</url>
      
        <content type="html"><![CDATA[<p>肝算法第一天</p><a id="more"></a><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。注意：答案中不可以包含重复的三元组。</p><pre><code class="js">// eg: list: [-1, 1, -2, 0] target: 0// 输出: [-1, 0, 1]</code></pre><p><a href="https://leetcode-cn.com/problems/3sum/" target="_blank" rel="noopener">原题传送门</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><blockquote><p>可仿照两数之和暴力三层遍历，最后去重处理，但无意义</p></blockquote><ul><li><p>指针查数</p><p>选取一个数固定住(例如第一个),选择第二个和最后一个数，作为指针 <code>left</code> <code>right</code>, left++ 和 right–，不断循环找到结果</p></li><li><p>数组排序</p><p>原数组排序后，更适合双指针确定范围并查询</p><pre><code class="js">const list = [-2, -1, 0, 1, 2];const target = 0;/**  -2 | -1 2 (-1 + 2 小于 0 - -2， 所以 left 指针++)  -2 | 0 2 返回 [-2, 0, 2]   -1 | 0 2 (0 + 2 大于 0 - -1， 所以 right -- )  -1 | 0 1 返回 [-1, 0, 1]  0 | 1 2 到头了弟弟*/</code></pre></li></ul><p>如此思路开始构造函数</p><pre><code class="js">function sumThreeNum(list, target) {    const sl = list.sort((a, b) =&gt; a - b);    const res = [];    for (let i = 0, len = list.length; i &lt; len; i++) {        const curr = sl[i];        const st = target - curr; // st subTarget        let l = i + 1;        let r = len - 1;        // 因为是排序后的数组，所以后面必然比目标大        if (curr &gt; target) break;        // 避免当前固定数 与上次固定数一样        if (i === 0 || sl[i - 1] !== curr) {            while (l &lt; r) {                /**          核心逻辑           若左右之和等于子目标 则输出          若左右之和小于子目标 则 left 指针进一位          若左右之和大于子目标 则 right 指针减一位          靠指针缩进范围查询        */                if (sl[l] + sl[r] === st) {                    res.push([sl[i], sl[l], sl[r]]);                    // 避免下个指针数值和当前数值一样                    while (l &lt; r &amp;&amp; sl[l + 1] === sl[l]) l++;                    while (l &lt; r &amp;&amp; sl[r - 1] === sl[r]) r--;                    l++;                    r--;                } else if (sl[l] + sl[r] &lt; target) {                    l++;                } else {                    r--;                }            }        }    }    return res;}</code></pre><blockquote><p>要记住双指针的解法</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020前端面试题集-vue向</title>
      <link href="/2021/01/07/interview-2020/"/>
      <url>/2021/01/07/interview-2020/</url>
      
        <content type="html"><![CDATA[<p>2020下半年并不顺利，产品被其他平台诉讼下架，于是公司解散了无收益且吃钱的技术团队。突发事件显然超出了我的预期计划，在边玩边玩边玩边看题了大半月后，开始踏上面试之路。</p><p>这里集合一下本人遇到的全部面试题，题目顺序按照面试流程和出现频率降序，若是有点名气的厂会加名称。</p><h2 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h2><p>这环节的面试官一般分为两种情况：</p><ul><li><p>已看过简历了解情况后，通过自我介绍看个人总结能力和突出亮点</p></li><li><p>未看简历，想直接获取个人技术栈等情况，选择问题</p></li></ul><p>此时介绍并不建议将简历内容完整复述一遍，没有营养啊。尽量控制介绍时间在3分钟以内，我将这环节提炼出以下几点：</p><ul><li><p>个人技术栈</p></li><li><p>杰出项目或处理过的最有成就感的问题(挑一二稍微描述下，后续面试官有兴趣会追问)</p></li><li><p>工作中的软实力(促进团队协作、推动团队发展、带人经验、项目架构经验等)</p></li><li><p>日常如何提升自我(可以是技术方面，可以是其他方面，主要看个人的学习能动性和学习方式)</p></li><li><p>拿得出手的开源项目</p></li></ul><p>以上挑3、4点介绍基本就ok了，尽量简洁，抓重点</p><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><ol><li><p><a href="https://yuchengkai.cn/docs/frontend/browser.html#event-loop" target="_blank" rel="noopener">js的event loop</a></p><blockquote><p>无论直接问或者拐弯问，总之基本必问 —— 字节、哈喽</p></blockquote><ul><li>宏任务、微任务有哪些</li><li>宏任务如何处理(每次执行几个)</li></ul></li><li><p><a href="https://juejin.cn/post/6844903767226351623" target="_blank" rel="noopener">如何处理跨域问题</a></p><blockquote><p>也是必问 —— 字节、美团</p></blockquote><ul><li>jsonp原理、优劣<ul><li>img标签src能否使用</li></ul></li><li>cors如何设置</li></ul></li><li><p><a href="https://segmentfault.com/a/1190000015042902" target="_blank" rel="noopener">深浅拷贝</a></p><blockquote><p>建议做到手写 —— 携程</p></blockquote><ul><li>浅拷贝如何实现(es5, es6)</li><li>深拷贝如何处理循环引用</li></ul></li><li><p>throttle &amp;&amp; debounce</p><blockquote><p>建议手写</p></blockquote><ul><li>原理，应用场景，手写</li></ul></li><li><p><a href="https://lucifer.ren/fe-interview/#/?id=javascript-%f0%9f%97%92%ef%b8%8f" target="_blank" rel="noopener">call\apply\bind</a></p><ul><li>手动实现，区别</li></ul></li><li><p>css水平垂直居中布局</p><blockquote><p>也属于基本必考点 —— 字节、美团</p></blockquote></li><li><p><a href="https://juejin.cn/post/6844903809206976520?utm_source=gold_browser_extension%3Futm_source%3Dgold_browser_extension" target="_blank" rel="noopener">new 的实现原理</a></p></li><li><p>this 的指向</p></li><li><p><a href="https://es6.ruanyifeng.com/#docs/let" target="_blank" rel="noopener">let、const、var</a></p><ul><li>什么是变量提升</li></ul></li><li><p><a href="https://juejin.cn/post/6844903767654023182" target="_blank" rel="noopener">Promise</a></p><blockquote><p>建议根据A+原理手写</p></blockquote><ul><li>原理实现</li><li>与async区别</li><li>外部try catch能否捕获异常</li><li>扩展方法的意义(all\race\finally\any)</li></ul></li><li><p>Set\Map</p><ul><li>数据结构</li><li>应用场景</li></ul></li><li><p><a href="https://zhuanlan.zhihu.com/p/47407398" target="_blank" rel="noopener">浏览器渲染问题</a></p><ul><li>渲染顺序</li><li><a href="https://zh.javascript.info/script-async-defer" target="_blank" rel="noopener">defer\async 的区别，对应的加载时机</a></li><li><a href="https://zhuanlan.zhihu.com/p/48521680" target="_blank" rel="noopener">prefetch\preload 区别，原理</a></li></ul></li><li><p><a href="https://chinese.freecodecamp.org/news/javascript-implicit-type-conversion/" target="_blank" rel="noopener">数据隐式转换</a></p><ul><li>隐式转换如何触发(== + !…)</li><li>类型转换的规则</li></ul></li><li><p>instanceof 原理</p></li><li><p>重绘重排</p></li></ol><h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><ol><li><p><a href="https://www.php.cn/js-tutorial-457006.html" target="_blank" rel="noopener">vue响应式原理</a></p><blockquote><p>必问的，建议多看源码。有些面试官会将其与双向绑定混淆，可以顺带一起说 —— 字节、美团、哈喽</p></blockquote><ul><li>直接对data中数组的索引修改，是否会变化</li><li>增删对象属性，是否会变化</li><li>对数组类型的处理</li><li>为什么不对数组做依赖收集</li></ul></li><li><p>vue的key有什么作用</p><ul><li>不加key有什么影响</li><li>就地复用比重新创建性能高，如何选择</li></ul></li><li><p>vue diff算法如何处理</p></li><li><p>组件通信方式</p><ul><li>依赖注入的实现</li></ul></li><li><p>nextTick 原理</p><ul><li>如何实现在dom更新后执行(MutationObserver)</li><li>在事件流中的执行位置</li></ul></li><li><p>computed与watch</p><ul><li>区别、取舍</li><li>computed的缓存机制</li><li>computed能否被赋值</li></ul></li><li><p>虚拟dom</p><ul><li>原理，与原生dom区别</li></ul></li><li><p>keep-alive</p><ul><li>生命周期</li><li>原理</li></ul></li><li><p>父子组件渲染顺序</p><ul><li>生命周期执行顺序</li><li>通过props传递的数据，在父组件哪个阶段请求</li></ul></li><li><p>vue-router</p><ul><li>常用的mode，如何实现</li><li>浏览器回退按钮的事件</li><li>hash和history的优缺点，如何选择</li><li>如何修改hash</li></ul></li><li><p>vuex</p><ul><li>mutation与action区别</li></ul></li><li><p>react</p><blockquote><p>没看这方面的题，所以没让面试官问太多</p></blockquote><ul><li>react hooks优缺点</li><li>redux 与其他状态管理框架的比较</li></ul></li></ol><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><blockquote><p>字节对网络方面问的较多</p></blockquote><ol><li><p>导航栏输入内容点击回车后发生的事</p></li><li><p>请求响应头有哪些内容(字段)</p></li><li><p>缓存机制</p></li><li><p>restful 了解</p><blockquote><p>建议从阮一峰的restful架构开始看，api代表表现层状态转换的方式</p></blockquote><ul><li>如何设计restful规范的api</li><li>请求方法如何使用</li><li>options方法的用途</li></ul></li><li><p>前后端鉴权的方式有哪些</p><ul><li>如何理解jwt</li><li>cookie鉴权的优劣</li><li>页面对不同角色的处理</li></ul></li><li><p>ssr服务端渲染</p><ul><li>ssr与传统的jsp、php，同样是服务端出页面，有什么区别</li><li>生命周期</li><li>如何获取数据</li><li>应用场景</li></ul></li></ol><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ol><li><p>页面性能优化</p></li><li><p>webpack优化</p></li><li><p>babel 相关</p><ul><li>用途、原理</li><li>Object.assign()被babel处理后的语法</li><li>Promise被babel处理后的语法</li></ul></li><li><p>webpack相关</p><ul><li>由哪些模块构成</li><li>常用的webpack插件有哪些</li><li>loader的作用、原理</li><li>css-loader和style-loader区别</li></ul></li><li><p><a href="https://zhuanlan.zhihu.com/p/66331977" target="_blank" rel="noopener">图片格式的选择</a></p><ul><li>webp兼容性如何解决</li></ul></li><li><p>express与koa的区别</p><ul><li>中间件如何调用</li><li>app.use 执行顺序</li><li>如何选择</li></ul></li><li><p>小程序</p><ul><li>Taro 原理，遇到的坑点</li><li>各平台小程序的区别</li><li>小程序优化方案</li></ul></li><li><p>移动端页面</p><ul><li>如何解决1px问题</li><li>rem布局与vw布局</li><li>click 300ms延迟问题</li><li>flex布局</li></ul></li><li><p>html2canvas</p><ul><li>如何解决生成复杂图片会阻塞主线程问题</li></ul></li><li><p>对于用户输入内容如何过滤</p></li><li><p>如何设计一个完全解耦的组件</p></li><li><p>对一个项目的前端架构思路</p></li><li><p>项目中最困难的点，如何克服</p></li><li><p>最近学习的内容是什么</p></li><li><p>react\vue\express\js等等的最近动向，更新内容</p></li><li><p>面试官会根据个人做过的项目询问要点，记得提前整理出项目的细节</p></li></ol><h2 id="笔试-包括算法"><a href="#笔试-包括算法" class="headerlink" title="笔试(包括算法)"></a><a href="../interview-write-2020">笔试(包括算法)</a></h2><h2 id="薪资"><a href="#薪资" class="headerlink" title="薪资"></a>薪资</h2><p>说实话，并不会谈，都是根据目标薪资莽着要(很少计算)，导致劳资错过了几家offer</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CyberPunk2077</title>
      <link href="/2020/12/31/CyberPunk2077/"/>
      <url>/2020/12/31/CyberPunk2077/</url>
      
        <content type="html"><![CDATA[<blockquote><p>“赛博朋克2077真的是2020年我玩过的最精彩的游戏”  —— ElegantYU</p></blockquote><p>2020年初，赛博朋克2077就开始了预热，对于一个资深死肥宅来说，我立刻对其大致了解了一下，对于我的第一印象来说基本上就是八个字：光怪陆离，未来科技。</p><p>但是对我来说并没有太大的吸引力，科技怎么会比龙吼和魔法有意思呢？虽然对科技背景没有兴趣，不过对于赛博朋克的审美我还是吃的，霓虹遍地，以红紫蓝绿四种主色的渲染图，会让人有种都市迷离的沉醉之感。</p><p>终于，在这一年将画句号的时候，他来了。</p><h2 id="你好啊，V"><a href="#你好啊，V" class="headerlink" title="你好啊，V"></a>你好啊，V</h2><p>及其费时的装上百多G的游戏后，我按耐住开箱的激动心情，在一个安静的夜晚运行起来。</p><p>i5-9400f + 东芝3T蓝盘跑这款3A大作还是有点慢的，本着不烧显卡的原则，我选择了默认的配置（丐版1660挺难的，试过全特效，显卡都哭了）。据说游戏官方特意做了全游戏的汉化处理，请的中配水准也很高，那还等什么！果断切换中文。</p><p>果真，中文的原声除了一点点的翻译腔外，真的很接地气，国骂俚语章口就莱。“你可真是个二(er)货(bi)”、“往哪看呢，傻子(chou sha bi)”、“(ctmd)他妈的荒坂”，毫无违和十分过瘾。包括里面物品翻译(独爱菊3000)，能看到游戏的用心。</p><h2 id="Goo…d-Morning！夜之城！"><a href="#Goo…d-Morning！夜之城！" class="headerlink" title="Goo…d Morning！夜之城！"></a>Goo…d Morning！夜之城！</h2><p><img src="https://i.loli.net/2020/12/31/XzStjfqlsrp8NQD.png" alt="V的狗窝"></p><p>夜之城地图面积大概是GTA的两倍，对于一个大地图来说，难点就在于细节的把控和场景的切换，夜之城的场景让我觉得最惊讶的就是它的所有场景都是平铺式的，而不是像老滚的沙盒式切换，或者狂战士信条那种渐进+沙盒的模式，这种完整的体验性，百多G的游戏文件也情有可原。</p><p>里面的目标距离，速度计算，几乎完全是现实物理的等比缩放，就从做任务开车到下一个任务点来说，载具的速度，目的地的距离(城市要绕路)，和右上角所用时，稍微算一下差不多和真实送外卖的一样。这里要吐槽一下，一个是车确实不好开，没有自动驾驶和平稳速度，市内保持匀速前进全靠一下一下的W轰油门，车子一抖一抖，甚是难受；另一个是地图的路线导航太小，导致下个路口要拐弯的话，很容易开过，因为拐弯这个操作太难了…</p><p>载具的功能性不多，基本就是切换视角、收音机、方向控制，收音机是个小惊喜，经常会有很贴合场景或者人物心情的BGM出现(但是网易听歌搜不到！很气)，自己可以切换电台，听听娱乐频道、新闻时事啥的。</p><h2 id="电磁短路"><a href="#电磁短路" class="headerlink" title="电磁短路"></a>电磁短路</h2><p>赛博朋克的战斗系统类似于看门狗，是黑客技术 + 枪战 + 近战 + 暗杀的综合系统。作为一个合格的老银币，科技才是第一生产力，蹲墙角里，露个头扫描电子设备或者人(未来科技影响，人基本都是被科技改装过，并且可以接入芯片，义体啥的)，破译完了甩手一个定位，再接一个电磁短路，你死不死？再不行就关了摄像头，摸到你后面锁喉杀。</p><p>个人喜欢的第二个就是枪战(手雷战)了，枪械分为科技类和动能类，科技类的有些是蓄力获得大量伤害，有些是含有智能追踪的连发模式(这个贼爽，就是弹药消耗很快)，动能类的一般就是物理伤害+暴击的居多，还有一种跳弹的判定。中期女友帕南送的守望重狙也很生猛，爆头基本必死(准心长时间瞄准会飘忽)。</p><p>近战的类型很少玩，肉搏战不适合我这种柔弱的银币，不过尺有所短寸有所长，近战武器的dps普遍是同级枪械的2~3倍，并且有些义体的增幅简直变态，一把武士刀+幻影步，你开枪很难命中。所幸后期有义体故障和阻碍移动的插件芯片，远程破解幻影步。</p><p>总之首推银币科技流，做个远程入侵的黑客太舒服了，只要蹲的时间够长，就能把敌人一个个阴死。</p><p>战斗系统没什么大的毛病，只有一些细节问题，比如：尸体会把爆的装备盖住捡不到、偶尔有装备或尸体穿模的bug。遇到boss记得及时打血…</p><p><img src="https://i.loli.net/2020/12/31/Sq9cv3mwRZxnF8T.png" alt="武侍乐队主唱"></p><h2 id="数据永生还是苟延残喘"><a href="#数据永生还是苟延残喘" class="headerlink" title="数据永生还是苟延残喘"></a>数据永生还是苟延残喘</h2><p>以下会和夜之城的剧情有关，选择阅读。</p><p>前期，V因为一个雇佣兵任务，导致好基友杰克去世，也因为任务的芯片，自己的脑子里住上了一个小说里的“金手指” – 强尼·银手。</p><p>银手是50年前一个有理想且自负的摇滚疯子，他身前看透了荒坂公司对群众的阶级压迫，立志要打到荒坂，人民当家做主，之后更是因为自己女友的去世了解了荒坂公司的真正阴谋，私仇和大义站在一条线上，好男儿岂能无热血！于是联合自己的痴情前女友和一帮兄弟，偷袭荒坂总部。可惜，计划失败，自己交代在那里不说，人格记忆也被化成数据流存入荒坂秘密研发的灵魂芯片中。</p><p>V本是将死之人，却因为灵魂芯片保住一条狗命，不过芯片本身是beta版的，很多功能不完善，银手和V的人格数据经常会错乱，人格数据与这具身体产生了排异反应，V还是要死不死的状态。</p><p>至此，故事分为V和银手两条线，V一边以雇佣兵身份做任务，一边寻找解决问题保命的方法；银手作为一个控制心极强的人，一直想把V干掉，完全掌控身体，找到自己老兄弟然后复仇。一体双魂的状态让他俩有足够长的沟通时间，在长时间的磨合下，两人碰撞出友♂谊的火花，逐渐达成共识：干掉荒坂公司，活下去。</p><p>复仇\求生路上，V与多位女子结下了很深的羁绊，但是我只做到与流浪者少主“帕南”的成功上垒，其他的女人最多是个好闺蜜角色(不知道有没有多后宫结局)，这点颇为遗憾。强尼也联系上生前的人脉，时不时对V进行语言攻击，干扰V的决定。</p><p>主要人物的角色塑造都很好，人物性格，情感变化，包括每次做选择之后的语气变化，都很精细。唯一不足的就是主线剧情太短了，虽然通关一次之后可以选择继续游戏，尝试其他结局，但是总的来说，我肝了4-5天时间，就通关主线了，实在太短。V的情感线也是问题，像女友帕南，确定关系的CG只有一次就算了，后续的人物对话也太单调，都情侣关系了，可以多点互动或者任务剧情的触发啊(我要后宫！！)，同性恋朱迪和赛车的寡妇都可惜了，都是“唾沫那几”。</p><p>尽管是个开放世界，有着路边的随机小任务，但是主线结束后，也难掩单调。没有一个长期的有可变性的任务存在的话，夜之城很难留住我啊。</p><p>已经尝试了两种结局，最后都是选择V掌控身体，享受生命最后的绚烂。可能是主观因素吧，并不希望是第二人格留在现实，哪怕银手这个人物很潇洒，很牛逼，只要一想到用着原主的身体，泡着V的妞，还是会心里不爽(牛头人)。</p><p>从个人与命运的抗争，到对荒坂这个庞然大物的反扑，再到人类与人工智能的选择，整个剧情会给人带来很多很直接的反思，3A不愧为3A。</p><p><img src="https://i.loli.net/2020/12/31/tGkBbDhzT6VNL8i.png" alt="赛博空间的抉择"></p><h2 id="活下去"><a href="#活下去" class="headerlink" title="活下去"></a>活下去</h2><p>赛博朋克2077，是2020年为数不多的惊喜，希望下一个是老滚6。</p><p><img src="https://i.loli.net/2020/12/31/K18ksVQq4ZDyRUu.png" alt="再见，夜之城"></p><p>是继续留在日渐糜烂的夜之城，还是出发寻找心中的理想之地，又或是穿过黑墙选择永生？</p>]]></content>
      
      
      
        <tags>
            
            <tag> 游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-最长回文子串</title>
      <link href="/2020/11/09/longest-palindromic-substring/"/>
      <url>/2020/11/09/longest-palindromic-substring/</url>
      
        <content type="html"><![CDATA[<h1 id="最长回文子串-5"><a href="#最长回文子串-5" class="headerlink" title="最长回文子串 - 5"></a>最长回文子串 - 5</h1><p><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">原题链接</a></p><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><pre><code class="code">输入: &quot;babad&quot;输出: &quot;bab&quot;注意: &quot;aba&quot; 也是一个有效答案。--------输入: &quot;cbbd&quot;输出: &quot;bb&quot;</code></pre><h2 id="分析题意"><a href="#分析题意" class="headerlink" title="分析题意"></a>分析题意</h2><p>题目意思很好理解，回文：即正过来反过去都是同一个字符串。</p><blockquote><p>看到这里很多人一定想知道怎么获取最长回文子串，小编也想知道怎么获取最长回文子串，今天小编就带大家看一下什么是最长回文子串以及怎么获取最长回文子串。好了以上就是获取最长回文子串的方法，希望小编精心整理的这篇内容能够解决你的困惑。</p></blockquote><p>工作人员操作失误，竟被百家号小编抢走写了一段…好了，废话不多说，继续看题</p><p>首先，我们知道了什么是回文后，就可以得到如何判断字符串是否是回文</p><pre><code class="js">const s = &#39;abcba&#39;const r = s.split(&#39;&#39;).reverse().join(&#39;&#39;)if (s === r) return s</code></pre><p>稍微枚举下所有可能的字符串，便知道，我们可以使用两个循环遍历出所有的选择</p><pre><code class="bash">aababcabcbabcba ------bbcbcbbcba----....</code></pre><p>再看下边界条件，长度为0 或 1 的字符串可以作为回文字符串返回，长度 2 以上需要做判断。</p><p>综合以上条件，可以用暴力解法得到</p><h3 id="暴力解题"><a href="#暴力解题" class="headerlink" title="暴力解题"></a>暴力解题</h3><pre><code class="js">const longestPalinDromeForce = s =&gt; {  const len = s.length  const cache = []  //  存放所有回文子串  if (len &lt; 2) return s  for (let i = 0; i &lt; len; i++) {    for (let j = 0; j &lt; len; j++) {      const curr = s.slice(i, j + 1)      const res = curr.split(&#39;&#39;).reverse().join(&#39;&#39;)      curr === res &amp;&amp; cache.push(curr)    }  }  // 所有子串长度递减排序 拿最长的  const max = cache.sort((a, b) =&gt; b.length - a.length)[0]  return max}longestPalinDromeForce(&#39;abbac&#39;)  //  输出： abba</code></pre><p>wocao!太简单了吧，虽然很暴力，“又不是不能用”。</p><p>我们在内部加上<code>console.time(&#39;暴力解法&#39;)</code> 和 <code>console.timeEnd(&#39;暴力解法&#39;)</code>看下运行用时，换上这个例子</p><pre><code class="js">longestPalinDromeForce(&#39;jrjnbctoqgzimtoklkxcknwmhiztomaofwwzjnhrijwkgmwwuazcowskjhitejnvtblqyepxispasrgvgzqlvrmvhxusiqqzzibcyhpnruhrgbzsmlsuacwptmzxuewnjzmwxbdzqyvsjzxiecsnkdibudtvthzlizralpaowsbakzconeuwwpsqynaxqmgngzpovauxsqgypinywwtmekzhhlzaeatbzryreuttgwfqmmpeywtvpssznkwhzuqewuqtfuflttjcxrhwexvtxjihunpywerkktbvlsyomkxuwrqqmbmzjbfytdddnkasmdyukawrzrnhdmaefzltddipcrhuchvdcoegamlfifzistnplqabtazunlelslicrkuuhosoyduhootlwsbtxautewkvnvlbtixkmxhngidxecehslqjpcdrtlqswmyghmwlttjecvbueswsixoxmymcepbmuwtzanmvujmalyghzkvtoxynyusbpzpolaplsgrunpfgdbbtvtkahqmmlbxzcfznvhxsiytlsxmmtqiudyjlnbkzvtbqdsknsrknsykqzucevgmmcoanilsyyklpbxqosoquolvytefhvozwtwcrmbnyijbammlzrgalrymyfpysbqpjwzirsfknnyseiujadovngogvptphuyzkrwgjqwdhtvgxnmxuheofplizpxijfytfabx&#39;)// 输出  暴力解法: 1192.661ms</code></pre><p>面试官集体失声，哭着对你说：咱优化下吧。</p><h3 id="再次分析"><a href="#再次分析" class="headerlink" title="再次分析"></a>再次分析</h3><p>究竟是什么导致执行时间这么长呢，我们从头思考下，回文的特性</p><ul><li><strong>回文两端必相等</strong></li><li><strong>一个回文首尾加上相同的字符，必是回文</strong></li></ul><p>例如：</p><pre><code class="js">const str = &#39;ababc&#39;// a √// ab 两端不相等 ×// aba 两端相等，中间 b 是回文 √// abab 两端不等 ×// ...// b √// ba 两端不等 ×// bab 两端相等，中间 a 是回文 √// ...</code></pre><p>由此，我们可以得到回文判断方程 </p><p><code>是否是回文 = (s[i] === s[j] &amp;&amp; s[i + 1] === s[j - 1] &amp;&amp; s[i + 2] === s[j - 2]...)</code></p><p>如上述回文特性第二条所说，两端相等且中间是回文的，必是回文，再次简化</p><p><code>回文 = s[i] === s[j] &amp;&amp; 中间是回文</code></p><p>判断公式有了，下一步就是获取 (i … j) 区间内字符是否是回文的判断了，这时候有人说了</p><p>“我知道我知道，里面再加个递归嘛，这题我会”</p><p>面试官悠长得吐了口烟：“回去等通知吧”</p><p>……</p><p>按照暴力解法里面的遍历顺序，我们没有办法去提前得知 <code>a...a</code> 中间是否是回文，但是 i++ 下次循环就可以得到下一层的首尾判断，所以我们逆向循环试试</p><pre><code class="js">const s = &#39;abbav&#39;const len = s.length// 从尾部开始for (let i = len - 1; i &gt;= 0; i--) {  // 内部循环需从当前 i 位置，开始遍历保证截取字符串的顺序  for (let j = i; j &lt; len; j++) {    // 内部枚举如下    // 4 4 v    // 3 3 a    // 3 4 av    // 2 2 b    // 2 3 ba    // 2 4 bav    // 1 1 b    // 1 2 bb    // 1 3 bba    // 1 4 bbav    // 0 0 a    // 0 1 ab    // 0 2 abb    // 0 3 abba    // 0 4 abbav  }}</code></pre><p>又因为 (i … j) 区间内部的回文，我们不需要知道具体内容，只需要一个判断的结果，在循环外加上一个二维数组存入i、j坐标，及其判断结果，下次循环直接利用存入的判断，减少重复判断</p><p>至此，我们再写一下</p><pre><code class="js">const len = s.lengthlet cache = []  //  坐标数组for(let i = len - 1; i &gt;= 0; i--) {  cache[i] = [] //  初始化 i 位置  for (let j = i; j &lt; len; j++) {    if (j - i === 0) {  //  单个字符      cache[i][j] = true    } else if (j - i === 1 &amp;&amp; s[i] === s[j]) {  //  两个字符      cache[i][j] = true    } else if (s[i] === s[j] &amp;&amp; cache[i + 1][j - 1]) {  //  多个字符      cache[i][j] = true    }    if (cache[i][j]) {      console.log(&#39;这个区间的字符 就是回文字符&#39;)    }  }}</code></pre><h3 id="最终整合版"><a href="#最终整合版" class="headerlink" title="最终整合版"></a>最终整合版</h3><pre><code class="js">const longestPalindrome = (s) =&gt; {    console.time(&quot;最终整合版&quot;);    const len = s.length;    if (len &lt; 2) return s;    let cache = [];    let max = &quot;&quot;;    for (let i = len - 1; i &gt;= 0; i--) {    cache[i] = []        for (let j = i; j &lt; len; j++) {            if (j - i === 0) {                cache[i][j] = true;            } else if (j - i === 1 &amp;&amp; s[i] === s[j]) {                cache[i][j] = true;            } else if (s[i] === s[j] &amp;&amp; cache[i+1][j-1]) {                cache[i][j] = true;            }      // 判断长度 替换max            if (cache[i][j] &amp;&amp; j - i + 1 &gt; max.length) {                max = s.slice(i, j + 1);            }        }    }    console.timeEnd(&quot;最终整合版&quot;);    return max;};longestPalindrome(&quot;jrjnbctoqgzimtoklkxcknwmhiztomaofwwzjnhrijwkgmwwuazcowskjhitejnvtblqyepxispasrgvgzqlvrmvhxusiqqzzibcyhpnruhrgbzsmlsuacwptmzxuewnjzmwxbdzqyvsjzxiecsnkdibudtvthzlizralpaowsbakzconeuwwpsqynaxqmgngzpovauxsqgypinywwtmekzhhlzaeatbzryreuttgwfqmmpeywtvpssznkwhzuqewuqtfuflttjcxrhwexvtxjihunpywerkktbvlsyomkxuwrqqmbmzjbfytdddnkasmdyukawrzrnhdmaefzltddipcrhuchvdcoegamlfifzistnplqabtazunlelslicrkuuhosoyduhootlwsbtxautewkvnvlbtixkmxhngidxecehslqjpcdrtlqswmyghmwlttjecvbueswsixoxmymcepbmuwtzanmvujmalyghzkvtoxynyusbpzpolaplsgrunpfgdbbtvtkahqmmlbxzcfznvhxsiytlsxmmtqiudyjlnbkzvtbqdsknsrknsykqzucevgmmcoanilsyyklpbxqosoquolvytefhvozwtwcrmbnyijbammlzrgalrymyfpysbqpjwzirsfknnyseiujadovngogvptphuyzkrwgjqwdhtvgxnmxuheofplizpxijfytfabx&quot;)//  输出 最终整合版: 19.145ms！！！！</code></pre><p>面试官：“我们来谈谈薪资吧”</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>对于这种内部子循环可以复用，且有一个<code>条件|状态</code>判断方程的，我们都可以使用这种解法思想去实现，此之谓“动态规划”。</p><ul><li>确定题目结果的特性</li><li>根据推导过程抽象得到一个判断方程(正推，逆推都需要，获得最优解)</li><li>思考如何省略可复用结果</li><li>获取初始值 和 边界情况的判断</li><li>结果输出的判断</li></ul><p>当然，条条大路通罗马，解法是没有定数的，一定还有更优的解法，但毕竟本人也不是专门肝算法的，能够用一个不错的算法思想去解决问题，Enough~</p>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-两数相加</title>
      <link href="/2020/11/04/add-two-numbers/"/>
      <url>/2020/11/04/add-two-numbers/</url>
      
        <content type="html"><![CDATA[<h1 id="两数相加-2"><a href="#两数相加-2" class="headerlink" title="两数相加 - 2"></a>两数相加 - 2</h1><p><a href="https://leetcode-cn.com/problems/add-two-numbers/" target="_blank" rel="noopener">原题链接</a></p><p>给出两个 <strong>非空</strong> 的链表用来表示两个<strong>非负</strong>的整数。其中，它们各自的位数是按照 <strong>逆序</strong> 的方式存储的，并且它们的每个节点只能存储 <strong>一位</strong> 数字。</p><p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p><p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><pre><code class="code">输入: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出: 7 -&gt; 0 -&gt; 8原因: 342 + 465 = 807</code></pre><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><pre><code class="js">/** * Definition for singly-linked list. * function ListNode(val, next) { *     this.val = (val===undefined ? 0 : val) *     this.next = (next===undefined ? null : next) * } *//** * @param {ListNode} l1 * @param {ListNode} l2 * @return {ListNode} */var addTwoNumbers = function (l1, l2) {  let result = temp = new ListNode()  let exceed = 0  while (l1 || l2 || exceed) {    const sum = (l1 &amp;&amp; l1.val || 0) + (l2 &amp;&amp; l2.val || 0) + exceed    const [e, n] = sum.toString().padStart(2, &#39;0&#39;)    l1 = l1 &amp;&amp; l1.next    l2 = l2 &amp;&amp; l2.next    exceed = Number(e)    temp = temp.next = new ListNode(sum)  }  return result.next}</code></pre><h2 id="心路历程"><a href="#心路历程" class="headerlink" title="心路历程"></a>心路历程</h2><h3 id="理解题意"><a href="#理解题意" class="headerlink" title="理解题意"></a>理解题意</h3><p>看到题目，迅速扫过一眼…</p><p>什…什么?! 我竟然没有看懂!</p><p>逐字逐句再看一遍…</p><p>哦~原来是这样 (完全没懂啊！淦！我不信！)</p><p>……</p><p>题目需求：一个函数，入参两个逆序的链表，输出两个链表对位相加且可进位的链表 4 + 6 =&gt; 0 (进1，下一位求和 + 1)。</p><p>理解需求后，再看示例</p><pre><code class="js">// Definition for singly-linked list.function ListNode(val, next) {  this.val = (val===undefined ? 0 : val)  this.next = (next===undefined ? null : next)}</code></pre><p><code>ListNode</code> 就是题目链表结构数据的构造函数。</p><p>eg: 2 -&gt; 4 -&gt; 6</p><p>val =&gt; 返回当前位置的数据 (eg: 2)</p><p>next =&gt; 返回一个剩下数据的 ListNode 链表 (eg: 4 -&gt; 6)</p><p>数据结构清晰之后，就开始完成题目吧~</p><h3 id="继续思考"><a href="#继续思考" class="headerlink" title="继续思考"></a>继续思考</h3><p>怎么实现对位相加呢…有了！不如把入参的链表转换成数组形式，reverse后再转成字符串，l1 + l2 隐式转换的结果再转成字符串，再转数组，再转链表…</p><p>u1s1，可以，但没必要，会显得自己很蠢</p><hr><p>再回想一下 <code>ListNode</code> 的内部结构，提供 val 返回当前值，.next.val 返回下个位置值，.next.next.val 返回下下位置值…</p><p>我们是不是每个位的和利用 val 进行相加呢，然后只要每次获取后一位的值相加，就能获得每个位置的和，之后再转链表结构就OK🙆‍♂️了</p><p>嗯？仔细一想，有必要最后去转链表吗？先把它new出来，给其val赋值不就完了</p><p>那么问题来了，怎么去每次获取 l1 &amp; l2 后一位值呢 l1.next.next.next….</p><p>看到这么多重复的 next 相比你已经知道了。没错，是递归！而，所有递归都是可以用循环表示，所以，我们使用 <strong>whlie</strong> 语句</p><p>怎么在while里获取两个链表的next呢，这里便是这道题的精妙之处，将链表 <strong>A</strong> 的 <strong>A.next</strong> 再获取完当前位的val之后，再赋值给 <strong>A</strong>!</p><p>”啊！原来是这样吗！“</p><p>”可恶，为什么我没想到！“</p><p>”斗宗强者恐怖😱如斯？“</p><p>”大佬大佬，我悟了！666！“</p><p>基操，勿6，皆坐，静观</p><p>同理可得，我们需要返回的链表 <strong>result</strong> 是不是也可以将求和的结果放在 <strong>next</strong> 里面，如</p><pre><code class="js">// 伪代码const result = new ListNode()const sum = l1.val + l2.valresult.next = new ListNode(sum)// 但是！只有这样是不够的！因为下次next赋值，会覆盖掉这次的值，所以 ⬇️result = result.next// 啊 这！你这样做的话那result将会是一个只有一个值的链表，而不是我们需要返回的一串数据！// heh，还是，被看穿了吗，那么，这样如何！// 将第一步 result = new ListNode() 换成let result = temp = new ListNode()temp = temp.next = new ListNode(sum)// 学吧，学无止境，太深了</code></pre><p>接着，是求和进位的问题，每次需要把进位加到下一次里面，我们可以在循环外定义这个进位的变量 <code>exceed</code></p><pre><code class="js">let exceed = 0while () {  const sum = l1.val + l2.val + exceed  // 转成字符串后使用padStart方法使字符串保持两位，若是一位数则首位填充 0  // 解构出来的变量e即为进位  // 你也可以直接数字模10 取余数  const [e, n] = sum.toString().padStart(2, &#39;0&#39;)  exceed = Number(e)}</code></pre><p>最后，只剩一个 <del>调教</del> 条件 了，循环的跳出条件</p><p>在入参链表获取到最后一位的时候跳出，但是题目没有说明两个参数的长度是否一致，所以，需要两个参数都判断。怎么判断呢？上面，我们在循环内部做了 <code>l1 = l1.next</code> 剩余链表结构赋值给其本身，根据已知条件，<code>this.next = (next===undefined ? null : next)</code>，可得在 l1 || l2 为true时需要继续执行。哎！是不是漏了什么，exceed呢？我这么大个进位呢？要是俩入参读完之后要进位咋办嘛。</p><p>最后最后，可得条件 <code>l1 || l2 || exceed</code> 时继续执行循环</p><p>推断结束，开撸开撸！</p><h3 id="撸代码"><a href="#撸代码" class="headerlink" title="撸代码"></a>撸代码</h3><pre><code class="js">// 目前的思路var addTwoNumbers = function (l1, l2) {  let result = temp = new ListNode()  let exceed = 0  while (l1 || l2 || exceed) {    // 万一 l1 || l2 谁跑完了...又是一个小细节    const sum = (l1 &amp;&amp; l1.val || 0) + (l2 &amp;&amp; l2.val || 0) + exceed    const [e, n] = sum.toString().padStart(2, &#39;0&#39;)    l1 = l1 &amp;&amp; l1.next    l2 = l2 &amp;&amp; l2.next    exceed = Number(e)    temp = temp.next = new ListNode(sum)  }  // 因为new的时候首位是0，后面用的又都是next  return result.next}</code></pre><p>简单却不失内涵，<del>每天一件潮流穿搭…</del></p><p>慢慢悟吧</p>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>私人珍藏大放送</title>
      <link href="/2020/06/13/wallpagerShare2006/"/>
      <url>/2020/06/13/wallpagerShare2006/</url>
      
        <content type="html"><![CDATA[<p>在下自幼便对文艺方向的事物充满着好奇向往，在艺术文学领域展现了独特的天赋和创造力。<br>基于种种原因，我的创作之路在初三时期缓缓地画上了分号，之后，随着互联网浪潮的侵袭及个人求学规划的影响，重续道路想法未熄，却已无青春时每日躁动不安喷渤狂涌一般的灵感。偶有作品，也是带着一股固执僵化的死板之感，不甚满意。<br>好在审美的嗅觉犹在，一直努力去寻找属于个人的风格，到头来发现三个字：何必呢。舒服好看即真理，过分的偏向某种类型，等于自上枷锁，海纳百川中和恒常才是适合的道路。</p><blockquote><p>“反正没人看，想说什么说便是。”  ——鲁迅</p></blockquote><h2 id="电脑壁纸分享"><a href="#电脑壁纸分享" class="headerlink" title="电脑壁纸分享"></a>电脑壁纸分享</h2><p><img src="https://i.loli.net/2020/06/13/PMeouOLKmTByNa8.jpg" alt="wallhaven-5wox18.jpg"><br><img src="https://i.loli.net/2020/06/13/rB5G3psNntvbgjR.jpg" alt="photo-1542293787938-c9e299b880cc.jpeg"><br><img src="https://i.loli.net/2020/06/13/UxZN18EoVcrClfF.jpg" alt="wallhaven-5wjjl9.jpg"><br><img src="https://i.loli.net/2020/06/13/UK6Vj4bsBCZ5MRu.jpg" alt="photo-1475598322381-f1b499717dda.jpeg"><br><img src="https://i.loli.net/2020/06/13/pNnOhCu1f5SLK7z.jpg" alt="wallhaven-4vm634.jpg"><br><img src="https://i.loli.net/2020/06/13/YpFc2JCiqtb5R3l.jpg" alt="photo-1576074578890-d84f564d2a0f.jpeg"><br><img src="https://i.loli.net/2020/06/13/ZCnS91vVt4ocBxi.jpg" alt="wallhaven-6k3vwl.jpg"><br><img src="https://i.loli.net/2020/06/14/bi6ze14cvhmjTUN.jpg" alt="wallhaven-45km14.jpg"><br><img src="https://i.loli.net/2020/06/14/2Ndt1jLzMiE3Bxy.jpg" alt="wallhaven-73mv5v.jpg"><br><img src="https://i.loli.net/2020/06/14/aD8dNgLsUpF93Vz.jpg" alt="wallhaven-76g589.jpg"><br><img src="https://i.loli.net/2020/06/14/5lHPdRY6UfQ3oSG.jpg" alt="wallhaven-371924.jpg"><br><img src="https://i.loli.net/2020/06/14/vUcngzAHO6F7YyQ.jpg" alt="wallhaven-673668.jpg"><br><img src="https://i.loli.net/2020/06/14/MuxtdE2FZOqGlmC.jpg" alt="wallhaven-dgp9eg.jpg"></p><h2 id="手机壁纸分享"><a href="#手机壁纸分享" class="headerlink" title="手机壁纸分享"></a>手机壁纸分享</h2><p><img src="https://i.loli.net/2020/06/14/68LDQSkzAMaeCTG.jpg" alt="111592114860_.pic.jpg"><br><img src="https://i.loli.net/2020/06/14/Vj5WAFvf9iKk4aq.jpg" alt="121592114861_.pic.jpg"><br><img src="https://i.loli.net/2020/06/14/SbLYiP369QRKynT.jpg" alt="131592114862_.pic.jpg"><br><img src="https://i.loli.net/2020/06/14/y5aXACxNqVnt8Gi.jpg" alt="151592114863_.pic.jpg"><br><img src="https://i.loli.net/2020/06/14/4QmZvkl5ab9U8pA.jpg" alt="141592114863_.pic.jpg"><br><img src="https://i.loli.net/2020/06/14/u7NBv9skbxlo3Ze.jpg" alt="181592114867_.pic.jpg"><br><img src="https://i.loli.net/2020/06/14/qExRPpWgTbQfOcz.jpg" alt="161592114864_.pic.jpg"><br><img src="https://i.loli.net/2020/06/14/WRaheSPBQZ82mCs.jpg" alt="191592114868_.pic.jpg"><br><img src="https://i.loli.net/2020/06/14/A4Eoeb5Q29Hiqhf.jpg" alt="171592114866_.pic.jpg"><br><img src="https://i.loli.net/2020/06/14/sC9fPrAD5Xju3hW.jpg" alt="221592114931_.pic.jpg"><br><img src="https://i.loli.net/2020/06/14/46JXd3kDCZ2INw9.jpg" alt="231592114932_.pic.jpg"><br><img src="https://i.loli.net/2020/06/14/n1L2ph5bVN7ryJe.jpg" alt="251592114934_.pic.jpg"><br><img src="https://i.loli.net/2020/06/14/osthD5idINE73rS.jpg" alt="211592114929_.pic.jpg"><br><img src="https://i.loli.net/2020/06/14/GuLaRS3YhyPFtmr.jpg" alt="281592114937_.pic.jpg"><br><img src="https://i.loli.net/2020/06/14/jpAzVvXGJx9U7dk.jpg" alt="301592114952_.pic.jpg"><br><img src="https://i.loli.net/2020/06/14/D3SmzP8c1V6hp2A.jpg" alt="321592115013_.pic.jpg"></p>]]></content>
      
      
      
        <tags>
            
            <tag> share </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一分钟搭建webpack+react的chrome-extensions项目</title>
      <link href="/2020/06/07/webpack+react/"/>
      <url>/2020/06/07/webpack+react/</url>
      
        <content type="html"><![CDATA[<p>客厅吹来的徐徐清风，一缕缕带走房间里沉闷的空气，窗外杨树摇摆着夏日繁茂的枝丫，趴在刚换完床单的床上，耳边“梭梭”声若隐若现，大自然的呢喃远比合成的白噪音悦耳。</p><p>周日，又一个阳光且慵懒的下午。</p><p>这是发布个人第二款浏览器插件<strong>Color Picker</strong>的第二天。</p><p>温吞吞的节奏中，慢慢学习使用react去打造插件应用，最终完成提交的那一刹那，心情却如尘埃落定，没有想象中的兴奋之感。<br>我果然还是更重视事件的初衷与过程而非结果，确定了方向后，不断的冲刺，无论道路的狭窄崎岖，只管记住目的，去学习，去克服，一次次的冲锋，一次次的受挫，一次次的进步。<br>这，才是最快乐时候。当到达高潮顶峰之后，只觉得本应如此。</p><hr><p>闲言碎语不多讲，来看看基础的项目如何构建。</p><h1 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h1><p>众所周知，一个webpack的配置主要由<strong>mode(模式)</strong>、<strong>entry(入口)</strong>、<strong>output(出口)</strong>、<strong>loader(转换器)</strong>、<strong>plugin(插件)</strong>构成，下面开始手把手搭建一个项目。</p><h2 id="init"><a href="#init" class="headerlink" title="init"></a>init</h2><pre><code class="bash"># 进入某个专门学习的文件夹mkdir react-app &amp;&amp; cd react-app # 创建项目文件夹并进入npm init -y # 快速创建package.json，跳过所有可选项</code></pre><p>此时一个package.json文件已创建好，里面的可选配置后续再说。</p><p>在项目根目录下，再创建文件夹<code>config</code>作为webpack配置文件的存放，新建文件<code>webpack.config.js</code>，我们要开始配置啦。</p><pre><code class="bash"># 下载模块yarn add webpack webpack-cli# 个人喜欢使用yarn，也可用npm</code></pre><h2 id="mode"><a href="#mode" class="headerlink" title="mode"></a>mode</h2><p>mode一项配置很简单也很重要，作为开发环境的判断，可选择为<code>development</code>或<code>production</code>，并根据不同的环境参数，配置不同的webpack优化。</p><pre><code class="js">// webpack.config.jsmodule.exports = {  mode: &#39;production&#39;}</code></pre><p>webpack中若无mode配置，也可在package.json的scripts中配置mode参数</p><pre><code class="json">// pakeage.json{  &quot;scripts&quot;: {    &quot;build&quot;: &quot;webpack --config=config/webpack.config.js --mode=production&quot;  }}</code></pre><p>到package.json这里就有人看不懂了<br>”哎？这里还能配置吗？我怎么看不懂啊？这是什么意思啊？“<br><del>好看的妹子请加微信求助私人辅导</del><br>咳咳，这里我将<code>npm init -y</code>创建的项目默认脚本命令删除了(test: echo什么的)。<br>创建了新的命令 名为<code>build</code>，其后的命令为<code>[启动的服务] --[参数名]=[参数值]</code></p><p>我们使用webpack的服务，配置其脚本地址(以package.json文件为根路径)，及mode环境。<br>之后再终端键入<code>npm run build</code>或<code>yarn build</code>即可启动打包命令</p><p>这里统一设置为生产环境。</p><h2 id="entry"><a href="#entry" class="headerlink" title="entry"></a>entry</h2><p>打包文件的入口，使用<code>path.resolve(__dirname, [path])</code>将文件相对路径转为绝对路径，基本配置如下：</p><pre><code class="js">const path = require(&#39;path&#39;)module.exports = {  entry: path.resolve(__dirname, &#39;./index.js&#39;)}</code></pre><p>由于开发插件的特殊性，需要配置成多入口：</p><pre><code class="js">module.exports = {  entry: {    // 入口文件自定义name: 路径    popup: path.resolve(__dirname, &#39;./popup.js&#39;),    background: path.resolve(__dirname, &#39;./background.js&#39;),    contentScript: path.resolve(__dirname, &#39;./contentScript.js&#39;),  }}</code></pre><h2 id="output"><a href="#output" class="headerlink" title="output"></a>output</h2><p>入口文件打包后的输出地址</p><pre><code class="js">module.exports = {  output: {    path: path.resolve(__dirname, &#39;../dist&#39;),    //  【name】使用entry配置的自定义name作为文件名，这里将输出到/dist/static/js/文件夹下    filename: &#39;static/js/[name].js&#39;,    // 根据上条filename的配置，决定了其chunkFilename的名称    // bundle即是打包过程中所使用的模块合并后的产物    chunkFilename: &#39;static/js/[name].bundle.js&#39;,  }}</code></pre><h2 id="module"><a href="#module" class="headerlink" title="module"></a>module</h2><p>module？不是loader吗，我这么大一个loader去哪了？<br>module便是用来配置不同类型的loader。<br>我们能配置什么呢？</p><h3 id="js-jsx"><a href="#js-jsx" class="headerlink" title="js/jsx"></a>js/jsx</h3><p>使用react，必不可少的就是jsx语法和es678…等等可能会用到的高级语法，所以需要用到babel模块将其转换为es5。</p><pre><code class="bash">yarn add babel-loader @babel/core @babel/plugin-proposal-class-properties @babel/plugin-transform-runtime @babel/preset-env @babel/preset-react</code></pre><ul><li><code>@babel/preset-env</code> 指定babel可以转化最新的js语法，而无需微观管理目标环境所需语法</li><li><code>@babel/preset-react</code> 使用jsx语法必不可少的模块</li><li><code>@babel/plugin-proposal-class-properties</code>  顾名思义是用于js class语法的转换</li><li><code>@babel/plugin-transform-runtime</code> 为自己的代码创造一个沙盒环境，因为<code>core-js</code>会对全局范围的内置对象进行编译，如：定义与规范不一致的 Promise 对象，core-js可能会覆盖自己定义的对象，@babel/plugin-transform-runtime模块就是将内置对象使用模块引入的方式，避免对全局作用域的污染</li></ul><p>下载完babel模块后，配置规则</p><pre><code class="js">module.exports = {  module: {    rules: [      {        test: /\.js(x)?$/,        exclude: /node_modules/,        use: [          {            loader: &quot;babel-loader&quot;,            options: {              presets: [&quot;@babel/preset-env&quot;, &quot;@babel/preset-react&quot;],              plugins: [&quot;@babel/plugin-transform-runtime&quot;],            },          },        ],      }    ]  }}</code></pre><h3 id="css预处理"><a href="#css预处理" class="headerlink" title="css预处理"></a>css预处理</h3><p>根据个人口味选择loader，这里是scss</p><pre><code class="bash">yarn add style-loader css-loader postcss-loader sass-loader node-sass</code></pre><blockquote><p>node-sass 可是太tm慢了</p></blockquote><pre><code class="js">module.exports = {  module: {    rules: [      {        test: /\.(sc|c)ss?$/,        use: [          &quot;style-loader&quot;,          &quot;css-loader&quot;,          {            loader: &quot;postcss-loader&quot;,            options: {              plugins: (loader) =&gt; [                require(&quot;postcss-import&quot;)({ root: loader.resourcePath }),              ],            },          },          &quot;sass-loader&quot;,        ],      },    ]  }}</code></pre><h3 id="img图片"><a href="#img图片" class="headerlink" title="img图片"></a>img图片</h3><p>安装<code>url-loader</code>&amp;<code>file-loader</code>，对代码中引用限制大小后的图片，做转base64处理，减少请求</p><pre><code class="js">module.exports = {  module: {    rules: [      {        test: /\.(gif|png|jpeg|jpg|svg)(\?t=\d+)?$/,        use: [          {            loader: &quot;url-loader&quot;,            options: {              outputPath: &quot;static/images/&quot;,              limit: 10 * 1024,            },          },        ],      }    ]  }}</code></pre><h2 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h2><h3 id="html-webpack-plugin"><a href="#html-webpack-plugin" class="headerlink" title="html-webpack-plugin"></a>html-webpack-plugin</h3><p>此插件可根据入口文件生成一个html并引入js，或将js引入到自己配置的模板html中。</p><pre><code class="js">// 根据多页面的场景，将生成页面单独提出来，这样好看// moreTemplate.jsconst HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);const chunkNames = [  { chunk: &#39;popup&#39;, name: &#39;前置弹窗页&#39; },  { chunk: &#39;background&#39;, name: &#39;后置背景页&#39; },];module.exports = chunkNames.map(  ({ chunk, name }) =&gt;    new HtmlWebpackPlugin({      title: name,      filename: `${chunk}.html`,      template: `public/index.html`,      chunks: [&quot;vendor&quot;, chunk],      chunksSortMode: &quot;manual&quot;,    }));// webpack.config.jsconst templateList = require(&quot;./moreTemplate&quot;);module.exports = {  plugins: [    ...templateList,  ]}</code></pre><h3 id="uglifyjs-webpack-plugin"><a href="#uglifyjs-webpack-plugin" class="headerlink" title="uglifyjs-webpack-plugin"></a>uglifyjs-webpack-plugin</h3><p>压缩代码的插件，这没啥说的</p><pre><code class="js">const UglifyJsPlugin = require(&quot;uglifyjs-webpack-plugin&quot;);new UglifyJsPlugin({  test: /\.(js|jsx)/,  exclude: /node_modules/,  parallel: true,  sourceMap: true,}),</code></pre><h3 id="merge-jsons-webpack-plugin"><a href="#merge-jsons-webpack-plugin" class="headerlink" title="merge-jsons-webpack-plugin"></a>merge-jsons-webpack-plugin</h3><p>由于插件需要做国际化，在各模块中分别加入了其对应的message.json，使用此插件用于打包合并国际化的json</p><pre><code class="js">// 别问为什么抽出来，好看// mergeLocale.jsconst locales = [&quot;en&quot;,&quot;zh_CN&quot;,&quot;zh_TW&quot;]/** * pattern: 以项目根路径的相对路径，获取json文件拼接 * fileName: 填入output.publicPath的相对路径 */module.exports = locales.map((lang) =&gt; ({    pattern: `{./src/_locales/${lang}/messages.json,./src/**/_locales/${lang}/messages.json}`,    fileName: `./_locales/${lang}/messages.json`,}));// webpack.config.jsconst MergeJsonWebpackPlugin = require(&quot;merge-jsons-webpack-plugin&quot;);const MergeLocale = require(&quot;./mergeLocale&quot;);new MergeJsonWebpackPlugin({  debug: true,  output: {    groupBy: [...MergeLocale],  },}),</code></pre><h2 id="optimization"><a href="#optimization" class="headerlink" title="optimization"></a>optimization</h2><p>webpack中自带可配置的打包可重用模块代码分离优化功能</p><pre><code class="js">module.exports = {  optimization: {    usedExports: true, //  tree shaking 只支持import引入    splitChunks: {      minChunks: 1, //  需要拆分模块的最小引入次数      chunks: &quot;all&quot;,  //  选择分离的区域      cacheGroups: {  //  缓存组设置        vendor: {          name: &quot;vendor&quot;, //  分离出名为vendor的js，即chunkFilename中的name          test: /[\\/]node_modules[\\/]/,          priority: -10,        },      },    },  },}</code></pre><h2 id="prod-amp-watch"><a href="#prod-amp-watch" class="headerlink" title="prod &amp; watch"></a>prod &amp; watch</h2><p>根据业务需求，又新建两个文件，watch开发用，prod打包用</p><pre><code class="js">// webpack.watch.jsconst merge = require(&quot;webpack-merge&quot;);const config = require(&quot;./webpack.base&quot;);module.exports = merge(config, {  watch: true,  watchOptions: {    aggregateTimeout: 1000, // milliseconds    poll: 1000,    ignored: [&quot;node_modules&quot;],  },});</code></pre><pre><code class="js">// webpack.prod.jsconst merge = require(&quot;webpack-merge&quot;);const { CleanWebpackPlugin } = require(&quot;clean-webpack-plugin&quot;);const VersionList = require(&quot;./syncVersion&quot;);const config = require(&quot;./webpack.base&quot;);module.exports = merge(config, {    plugins: [        ...VersionList,        new CleanWebpackPlugin(),    ],});</code></pre><p>哎注意细节，这里我又加入一个versionList，这干嘛的呢？<br>没有错，是用来同步插件版本号</p><pre><code class="js">const version = require(&quot;../src/config.json&quot;).version; const WriteJsonWebpackPlugin = require(&quot;write-json-webpack-plugin&quot;);let package = require(&quot;../package.json&quot;);let manifest = require(&quot;../public/manifest.json&quot;);package.version = manifest.version = version;const list = [    { origin: &quot;../&quot;, filename: &quot;package.json&quot;, json: package },    { origin: &quot;../public&quot;, filename: &quot;manifest.json&quot;, json: manifest },    { origin: &quot;../dist&quot;, filename: &quot;manifest.json&quot;, json: manifest },];module.exports = list.map(    ({ origin, filename, json }) =&gt;        new WriteJsonWebpackPlugin({            pretty: true,            object: json,            path: origin,            filename,        }));</code></pre><p>这里抽离了版本号和国际化的所需国际语言数组<code>config</code>方便个人配置。</p><pre><code class="json">// package.json{  &quot;scripts&quot;: {    &quot;watch&quot;: &quot;webpack --config=config/webpack.watch.js&quot;,    &quot;build&quot;: &quot;webpack --config=config/webpack.prod.js&quot;,  },}</code></pre><p>到这里一个不使用devServer的chrome插件项目的配置就已经完成了，具体的代码文件，请移步到<a href="https://github.com/elegantYU/color-picker" target="_blank" rel="noopener">这里</a>欣赏(本身不想开源的，毕竟是个完整的产品，不过为了学习交流还是open了)<br>感觉不错的请不要怜惜我，狠狠地star吧！</p><blockquote><p>下章说下插件的开发流程，及我的插件架构思路，嘤嘤</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 一分钟教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>commit -am的正确姿势</title>
      <link href="/2020/05/11/git-commit-am/"/>
      <url>/2020/05/11/git-commit-am/</url>
      
        <content type="html"><![CDATA[<blockquote><p>记一次尴尬的提交…</p></blockquote><p>正常命令提交的某日<br>“每次都要add再commit，好麻烦啊，找一找有没有快捷命令..”<br>“还真有！<code>git commit -am &lt;message&gt;</code>，hhhh舒服了”</p><p>看着同事们还在按部就班的敲着<code>git add . | git commit -m</code>，我正了正身子，带着一丝’我懂你不懂’的窃喜轻描淡写地敲出了命令<br>“我提了”<br>“OK👌”<br>– A FEW MOMENTS LATER –<br>“你提哪了？”<br>“我…”<br>该死，不会是命令有问题吧，急忙查询了下命令与正常操作的区别</p><h2 id="git-commit-am-与-git-commit-m"><a href="#git-commit-am-与-git-commit-m" class="headerlink" title="git commit -am 与 git commit -m"></a>git commit -am 与 git commit -m</h2><p><code>git commit -am</code>用于提交已跟踪的文件(tracked)，<code>git commit -m</code>用于提交暂存区的文件。</p><p>什么是已跟踪文件呢，这要从Git文件状态变化周期说起了</p><h2 id="git-file-status-lifecycle"><a href="#git-file-status-lifecycle" class="headerlink" title="git file status lifecycle"></a>git file status lifecycle</h2><p><img src="https://i.loli.net/2020/05/11/WHxyFlS38t9ivcX.png" alt="lifecycle.png"></p><p>git内文件的状态分为<strong>未跟踪</strong>和<strong>已跟踪</strong>，一个新增的文件初始状态是<strong>untracked(未跟踪)</strong>，它既没有上次的记录(stage)，也不在暂存区中，在add该文件之后，文件就有了一次记录，针对其在做修改的话，会变成<strong>modified(已修改)</strong>状态。这时，使用commit会将已跟踪文件的变化提交暂存区。</p><p>了解了状态更替之后，再看commit -am。<br>这是git提供的一个跳过使用暂存区域的方式(跳过git add)，Git会自动把所有已跟踪过的文件暂存提交。</p><blockquote><p>命令中a参数的含义<br>OPTIONS<br>-a, –all<br>Tell the command to automatically stage files that have been modified and &gt;deleted, but new files you have not told Git about are not affected.</p></blockquote><p>翻译：git会自动把当前所有修改和删除文件放到stage里，但是没添加过的不受影响</p><p>看到这里，恍然大悟，随即重新add commit提交一次<br>“刚才网卡了，你再看看呢”<br>“哦哦，看到了”</p><blockquote><p>无它，唯菜耳</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Map不挺好用的,你还...</title>
      <link href="/2020/04/06/es6-map/"/>
      <url>/2020/04/06/es6-map/</url>
      
        <content type="html"><![CDATA[<p>闲来无事水一篇。</p><h2 id="Map"><a href="#Map" class="headerlink" title="Map?"></a>Map?</h2><p>记得那是es6，它带来了很多，很多改变。其中一个变化就是Map数据结构。</p><p>它和对象类似也是键值对的集合，但是“键”的范围不局限于字符串，各种类型的值都可以当做键。</p><p>概念源自<a href="https://es6.ruanyifeng.com/#docs/set-map#Map" target="_blank" rel="noopener">阮一峰es6</a></p><pre><code class="js">const map = new Map()// 操作方法map.set(&#39;dog&#39;, &#39;一种动物&#39;)  //  增map.get(&#39;dog&#39;)  //  &#39;一种动物&#39; 查map.has(&#39;tian dog&#39;) //  false 断言map.delete(&#39;dog&#39;) //  true 删除// 遍历方法map.keys()  //  返回键名遍历器map.values()  //  返回键值遍历器map.entries() //  返回所有成员的遍历器map.forEach() //  遍历所有map成员</code></pre><p>以上就是map实例的四种方法，那么就有读者问了：就这？我以为多厉害呢，就这？</p><h2 id="Map！"><a href="#Map！" class="headerlink" title="Map！"></a>Map！</h2><p>问的好！</p><p>这种东西就像是牙签，远看很不起眼，可是你近看，它还是就那样…不过！当你使用它把塞住牙缝中的肉丝儿整条挑出的时候，那种美妙舒爽的感觉会让你沉迷其中。</p><h4 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h4><p>现有确定的5种类型对应5个不同的值，怎么根据类型匹配返回对应的值呢？<br>“if else不香吗”<br>“还if else呢，switch case知道么”<br>“我不管！我就要硬写！学习？学个屁”</p><p>推了下眼镜，我要开始操作了</p><pre><code class="js">const typeMap = new Map([  [ &#39;花&#39;, &#39;某乐坛代表&#39; ],  [ &#39;日&#39;, &#39;指太阳&#39; ],  [ &#39;草&#39;, &#39;不只是植物&#39; ],  [ &#39;狗&#39;, &#39;一种常见的宠物&#39; ],  [ &#39;舔狗&#39;, &#39;指本人&#39; ],])const typeHandler = type =&gt; {  return typeMap.get(type)}typeHandler(&#39;狗&#39;)   //.. 输出 &#39;一种常见的宠物&#39;</code></pre><p>天哪，也太好用了8</p><p>“可是，用对象一样可以做啊”</p><h2 id="Object-Map"><a href="#Object-Map" class="headerlink" title="Object || Map"></a>Object || Map</h2><p>如一开始所说，Map对象有内置的迭代器，Object没有迭代器</p><pre><code class="js">console.log(typeof Object[Symbol.iterator])  //  undefinedconsole.log(typeof Map[Symbol.iterator])  //  function  Map[Symbol.iterator] == Map.entries()</code></pre><h4 id="异同"><a href="#异同" class="headerlink" title="异同"></a>异同</h4><ul><li>一个Object的键只能是字符串或者 Symbols，但一个 Map 的键可以是任意值，包括函数、对象、基本类型。</li><li>Map 中的键值是有序的，而添加到对象中的键则不是。因此，当对它进行遍历时，Map 对象是按插入的顺序返回键值。</li><li>Object对象若想遍历，需先获取其键数组，再进行迭代</li></ul><h4 id="取舍"><a href="#取舍" class="headerlink" title="取舍"></a>取舍</h4><p>若所有的键都是字符串、整数或Symbol类型且都是已知的，你需要一个简单的数据结构去存储，那么使用Object是一个不错的选择。毕使用key值获取元素比使用构造函数(get())获取元素的性能好。</p><p>如果考虑元素迭代或顺序，或是有大量的增删操作，则Map性能更优。</p><h2 id="if-？-switch-？"><a href="#if-？-switch-？" class="headerlink" title="if ？ switch ？"></a>if ？ switch ？</h2><p>Map数据结构的条件判断写法，优点显而易见的便是条件和结果的对应关系十分明朗，代码易读性极佳，降低了后续增改的维护工作，只需要加入条件和方法即可。</p><p>Map固然十分好用，能够有效的降低团队合作成本，并且看上去优雅。但这也不是完全抛弃传统条件判断的理由。</p><p>简单的逻辑使用if或swtich还是香的，我就是这么干的👍（露出洁白的牙齿，自信的微笑）</p><blockquote><p>水一水，十年少</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 都是皮毛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>梦随星逝了无痕</title>
      <link href="/2020/01/04/back-to-reality/"/>
      <url>/2020/01/04/back-to-reality/</url>
      
        <content type="html"><![CDATA[<p>what am I doing …</p><a id="more"></a><h2 id="2019"><a href="#2019" class="headerlink" title="2019"></a>2019</h2><p>今日，距公历的跨年，已过四天。</p><p>早在元旦前夕，就和同事提起过要对过去的每年，做一个年终总结。这不只是一种形式，而是对不断成长的自我的记录，对过去时间里的成果，做一次验收。万一明天就挂了，也该提前留下点什么。</p><p>记得去年 7 月份左右，公司里一个北京办公的老板来这里谈合作，临走前和公司员工开一次会，说是：每个人 20 到 30 的阶段，是过的最快的。其实之前也略有体会，直至他一语道破，我才如梦初醒般，原来，三年已过去。</p><p>三年之久，人人经历遭遇各有不同，高峰低谷满目皆是。私以为稳中求进方为王道，却也羡慕他人平步青云。</p><p>过去一年，只觉得自己昏昏噩噩，懵懵懂懂，像极了上课打瞌睡，耳中听着，笔下记着，中间醒过几次，却也顶不住阵阵困意，一堂课过后，也只剩满纸的鬼画符。</p><p>年初从上家公司果断离职，便一心想着找到顺自己心意的下家，本以做好“过冬”的心理准备，但还是被“碰”的稀里哗啦。最后还是像前几次一样，有坑就填，这种行为属实弟弟，但愿以后不会再有。入职之后，办公氛围和加班压力都比上家轻松很多，后面加入一个前端大佬后，心中更是自在。<br>就这样，我沦落了。</p><p>温柔乡，英雄冢。本就不善于表达的我，在大佬进入顶在我前面后，更是沉默。技术、迭代、需求跟进等等这一切，仿佛都与我无直接关系，我做的只是敲好这个需要的 for 循环，这种变化是潜移默化的。代码的魅力，在于创造。失去了创作欲望和能力的我，真正沦落成码农。我也想过去改变这种局面，却真是没有相应的能力和思维，一边又想着，也许明年就又换一家了呢？是哦，我从来就是这样选择逃避，再多几次也没有关系。<br>一年过去，我的成长远不如上家公司，一直都在被动的提升自己。自在的环境里，偶尔也会怀念高压的时候，人都是逼出来的。</p><h2 id="从来如此，便对么"><a href="#从来如此，便对么" class="headerlink" title="从来如此，便对么"></a>从来如此，便对么</h2><p>不仅是工作中，家庭、生活中，更是如此，因为菜场太远，便不想做饭；因为出门费劲，便不想出门；因为从小被束缚，现在便不愿主动和家人联系；因为想问题很累，便不再去想…<br>很多时候，逃避是一种束缚，选择面对才是一种解脱。</p><p>就在刚刚，和老妈语音之后才知道，她的生意不景气已经不准备继续下去，现在正报班培训婴幼儿护理，将来可能去做月嫂。如此大的变动，我竟浑然不知，听到她兼职其他工作后，一时间，心中五味杂陈。她身体本就不是很康健，却还要去做这种看人脸色的体力劳动，这对她无疑是很难顶得住的。若是我能多努力点，挣多点钱，事情会不会好一点。</p><p>物质社会，没人在乎个体感受，想要活下去，只能跟着它的规则走，挣钱。</p><h2 id="2020"><a href="#2020" class="headerlink" title="2020"></a>2020</h2><p>两纪已过，二十有四。新年伊始，希望自己的思想层次和技术能力更上一层楼，更重要的是对待问题的方式，不能再选择逃避了，要积极的处理问题。“战胜恐惧的最好方法，就是面对恐惧”（节选自《奥利给》），怪鸽才是那个把人生活得透亮的人啊。</p><p>加油吧 💪！</p>]]></content>
      
      
      <categories>
          
          <category> 夜晚 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>可选链?. 双问号??，这都是些啥</title>
      <link href="/2019/12/28/optional-chaining/"/>
      <url>/2019/12/28/optional-chaining/</url>
      
        <content type="html"><![CDATA[<p>上海的天气，终于能穿棉衣了</p><a id="more"></a><p>记得几个月前，某篇文章中便见过对可选链<code>?.</code>的讲解，当时打眼一看：这是个啥(黑人问号)，算了不看了，花里胡哨的。<br>直至某日，基友一页页代码入目，花哨且实用，这才狂拍大腿，表情狰狞却哑口无言。<br>”你也用过这些语法？“<br>”…不，我曾经见过“</p><h2 id="可选链"><a href="#可选链" class="headerlink" title="可选链 ?."></a>可选链 ?.</h2><blockquote><p>optional-chaining</p></blockquote><p>你是否写过这样的代码</p><pre><code class="js">// 若 a 存在，则判断 a.b 是否存在，再判断 a.b.c ，再...a &amp;&amp; a.b &amp;&amp; a.b.c &amp;&amp; ...</code></pre><p>每当写此等代码，无不是心中怒骂：真 egg pain！</p><p>如今，可选链操作符可帮你走出无限判断的困境。它允许读取一个被链接对象的深层次属性的值而无需明确校验连接上的每一条引用的有效性。</p><p>例如：</p><pre><code class="js">const yourSelf = {  name: &quot;小明&quot;,  age: 24,  pets: {    cat: {      name: &quot;狗剩&quot;    },    dog: null  }};const dogName = yourSelf.pets?.dog?.name;const catName = yourSelf.pets.cat?.name;const girlfriend = yourSelf?.girlfriend;console.log(dogName, catName, girlfriend);// print &gt; undefined &#39;狗剩&#39; undefined</code></pre><p>你甚至能用在更多的地方</p><pre><code class="js">function wantCallback(data, callback) {  try {    ...  }  catch (err) {    if (callback) {      callback(err.message)    }    // 或者这样？    callback &amp;&amp; callback(err.message)    // 不用这么麻烦，只需一步    callback?.(err.message)  }}</code></pre><h2 id="双问号"><a href="#双问号" class="headerlink" title="双问号 ??"></a>双问号 ??</h2><blockquote><p>nullish-coalescing-operator 合并操作符？不知道怎么翻译</p></blockquote><p>沿用上面的例子，如果输出你的女友数量，女友属性不存在或为 null 时输出’单身狗不配有女友这个属性’，该如何做呢</p><pre><code class="js">const yourSelf = {  ...  girlfriend: 0}console.log(yourSelf?.girlfriend || &#39;单身狗不配有女友这个属性&#39;)//  这样是预期结果吗，并不是，是希望你输出 0console.log(yourSelf?.girlfriend === 0 ? 0 : yourSelf?.girlfriend || &#39;单身狗不配有女友这个属性&#39;)//  虽然结果出来了，但是代码易读性却降低了很多，很不优雅</code></pre><p>传统的或运算符<code>||</code>会在运算结果为<code>0 false &#39;&#39; null undefined</code>时都使用设置的默认结果，而<code>0 false &#39;&#39;</code>都是需要实际输出的值。<br>这里，就可以使用双问号<code>??</code>运算符替代<code>||</code>，它会返回实际的结果.</p><pre><code class="js">const girlfriendNumber = yourSelf?.girlfriend ?? &quot;单身狗不配有女友这个属性&quot;;console.log(girlfriendNumber); //  输出 &gt; 0</code></pre><hr><p>是否很优雅、简洁、实用？那么请问<s>哪里能买到</s>怎么使用呢？<br>很简单，这两种特性都处于 stage3 的阶段，配置对应的 babel 插件即可尝鲜。</p><pre><code class="js">module.exports = {  plugins: [    &quot;@babel/plugin-proposal-optional-chaining&quot;,    &quot;@babel/plugin-proposal-nullish-coalescing-operator&quot;  ]};</code></pre><p>新版本的 typescript 已全支持两种运算符(羡慕).</p><pre><code class="yml">- Stage 0 - Strawman: just an idea, possible Babel plugin.- Stage 1 - Proposal: this is worth working on.- Stage 2 - Draft: initial spec.- Stage 3 - Candidate: complete spec and initial browser implementations.- Stage 4 - Finished: will be added to the next yearly release.</code></pre>]]></content>
      
      
      <categories>
          
          <category> 都是皮毛 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>迷僧</title>
      <link href="/2019/12/08/lyric-ms/"/>
      <url>/2019/12/08/lyric-ms/</url>
      
        <content type="html"><![CDATA[<div class="aplayer" data-name='迷僧' data-artist='雪沉乐队' data-url='http://m10.music.126.net/20200405173757/e7edb50ad7f87bd0f43c2bdf74c0ece3/ymusic/f094/d5e0/b304/4c2bd204657d3b4b5aa0fda8dd8c3adc.mp3' data-lrc data-cover='https://i.loli.net/2020/04/05/JOno3B68Xw5v1M4.jpg' ></div><p>邪鬼横行, 满目佞宗.<br>鬼神乱世, 不得安生.</p><a id="more"></a><p>摩岩古刹，冽冽雄风</p><p>容我一缕，纵横西东</p><p>不患善导，岂容庞公</p><p>昆仑山下，醉锁五龙</p><p>迷不我知，时穷乃现</p><p>十万鬼雄，竞相争帆</p><p>旍旗整肃，孤鹰盘旋</p><p>斗杀魍魉，气冲霄汉</p><p>山，青翠满目破牢关</p><p>人去也，静水照大千</p><br><p>东瀛餐霞怜无处</p><p>西山逐日怨有时</p><p>五浊三涂迷吾辈</p><p>千江何曾映月迟</p><p>九绝危岩江东去</p><p>只消雁过长空</p><p>廓然无累，银汉冲十方</p><p>无量慈悲喜舍，盈法界</p><p>广大神通</p><p>风尘外，孤灯半盏</p><p>万法尽归宗</p><p>须在意，澄怀解真空</p>]]></content>
      
      
      <categories>
          
          <category> 摇滚 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>用时才想去百度的css技巧</title>
      <link href="/2019/10/21/cssisgood/"/>
      <url>/2019/10/21/cssisgood/</url>
      
        <content type="html"><![CDATA[<p>换季了，多喝热水 ♨️</p><a id="more"></a><p>这里的 css 部分是根据项目总结的，还有些有的没的，来自于个人兴趣。<br>瞧一瞧看一看，不要你一分钱，赔本赚吆喝。</p><p>多图预警!</p><h2 id="垂直水平居中-简易版"><a href="#垂直水平居中-简易版" class="headerlink" title="[垂直水平居中]简易版"></a>[垂直水平居中]简易版</h2><pre><code class="scss">.main {  height: 200px;  display: flex;  .box {    width: 100px;    height: 100px;    background-color: pink;    margin: auto;  }}</code></pre><p><img src="https://i.loli.net/2019/10/21/DFGkYZjnUI9gzbH.gif" alt="19112101.gif"></p><h2 id="flex-子元素单独靠右-左"><a href="#flex-子元素单独靠右-左" class="headerlink" title="[flex 子元素单独靠右/左]"></a>[flex 子元素单独靠右/左]</h2><pre><code class="scss">ul {  display: flex;  align-items: center;  justify-content: space-between;  li {    width: 100px;    height: 100px;    background-color: pink;    // margin-left: auto;  }}</code></pre><p><img src="https://i.loli.net/2019/10/21/KZEmDfbs3zIx6lX.gif" alt="19112102.gif"></p><h2 id="滚动条不占位"><a href="#滚动条不占位" class="headerlink" title="[滚动条不占位]"></a>[滚动条不占位]</h2><pre><code class="html">&lt;style&gt;  .main {    height: 100px;    overflow: overlay;  }&lt;/style&gt;&lt;body&gt;  &lt;div class=&quot;main&quot;&gt;    阿里斯顿将阿拉山口打算的，阿里斯顿将阿拉山口打算的，    阿里斯顿将阿拉山口打算的，阿里斯顿将阿拉山口打算的，    阿里斯顿将阿拉山口打算的，阿里斯顿将阿拉山口打算的，    阿里斯顿将阿拉山口打算的，阿里斯顿将阿拉山口打算的，    阿里斯顿将阿拉山口打算的，阿里斯顿将阿拉山口打算的，    阿里斯顿将阿拉山口打算的，阿里斯顿将阿拉山口打算的，  &lt;/div&gt;&lt;/body&gt;</code></pre><blockquote><p>行为与 auto 相同，但滚动条绘制在内容之上而不是占用空间。 仅在基于 WebKit（例如，Safari）和基于 Blink 的（例如，Chrome 或 Opera）浏览器中受支持。</p></blockquote><h2 id="图片设置等比例"><a href="#图片设置等比例" class="headerlink" title="[图片设置等比例]"></a>[图片设置等比例]</h2><pre><code class="scss">img {  width: 300px;  height: 100px;  object-fit: contain;}</code></pre><p><img src="https://i.loli.net/2019/10/21/k5KDsSOReahWqLd.gif" alt="19112103.gif"></p><blockquote><p>contain/cover 属性参照 background-size</p></blockquote><h2 id="filter-模糊滤镜"><a href="#filter-模糊滤镜" class="headerlink" title="[filter 模糊滤镜]"></a>[filter 模糊滤镜]</h2><pre><code class="scss">img {  filter: blur(2px);}</code></pre><p><img src="https://i.loli.net/2019/10/21/mI9ptxfe8RVP74a.gif" alt="19112104.gif"></p><blockquote><p>blur 函数内像素越大，模糊程度越高</p></blockquote><h2 id="filter-图片置灰"><a href="#filter-图片置灰" class="headerlink" title="[filter 图片置灰]"></a>[filter 图片置灰]</h2><pre><code class="scss">img {  filter: grayscale(0.8);}</code></pre><p><img src="https://i.loli.net/2019/10/21/2vtndUoANSj9Wpy.gif" alt="19112105.gif"></p><h2 id="css-性能优化"><a href="#css-性能优化" class="headerlink" title="[css 性能优化]"></a>[css 性能优化]</h2><pre><code class="scss">.main {  height: 200px;  &amp;:hover {    .box {      transform: translateX(0);      will-change: transform;    }  }  .box {    width: 200px;    height: 200px;    background-color: pink;    transform: translateX(-100%);    transition: transform 0.5s;  }}</code></pre><p><img src="https://i.loli.net/2019/10/21/jZL9AQhCf8xpO7E.gif" alt="19112106.gif"></p><blockquote><p>will-change 主要作用就是“增强页面渲染性能”，比 transform3D，scaleZ 要更语义化。<br>在页面点击、hover、滚动等事件会触发大面积的页面重绘或重排时，浏览器往往是没有准备的，只能被动使用 cpu 去计算与重绘，于是掉帧、卡顿就来了。<br>will-change 属性就是在行为触发前，通知浏览器启动 GPU 渲染。<br>不过 will-change 需要适度使用，全局开启 GPU 渲染的话，你的机器也受不了，这样反而是性能灾难。最好在事件发生时，加入此属性，事件结束时，及时将 will-change 去掉。</p></blockquote><h2 id="多行文字省略"><a href="#多行文字省略" class="headerlink" title="[多行文字省略]"></a>[多行文字省略]</h2><pre><code class="html">&lt;style&gt;  .more_list {    text-align: left;    text-overflow: ellipsis;    overflow: hidden;    display: -webkit-box;    -webkit-line-clamp: 2;    -webkit-box-orient: vertical;  }&lt;/style&gt;&lt;body&gt;  &lt;div class=&quot;box&quot;&gt;    &lt;p class=&quot;more_list&quot;&gt;      测试多行文字测试多行文字测试多行文字测试多行文字测试多行文字测试多行文字测试多行文字测试多行文字测试多行文字测试多行文字    &lt;/p&gt;    &lt;span class=&quot;more_list_en&quot;      &gt;howToDohowToDohowToDohowToDohowToDohowToDohowToDohowToDohowToDohowToDohowToDohowToDo&lt;/span    &gt;  &lt;/div&gt;&lt;/body&gt;</code></pre><p><img src="https://i.loli.net/2019/10/28/XE1Hq5i79FZeBhl.gif" alt="19102801.gif"></p><blockquote><p>-webkit-line-clamp 是一个不规范的属性，限制一个块元素显示的文本行数，为了实现该效果，需要其他 webkit 属性配合<br>display 属性为 -webkit-box ，-webkit-box-orient 用于控制盒子内子元素的排列顺序 vertical<br>若标签内是英文，英文是不会自动换行的，需要加入 word-wrap: break-word; word-break: break-all;</p></blockquote><h2 id="禁止当前盒子外的-scorll"><a href="#禁止当前盒子外的-scorll" class="headerlink" title="[禁止当前盒子外的 scorll]"></a>[禁止当前盒子外的 scorll]</h2><pre><code class="css">.div {  overscroll-behavior: none;}/**  *  默认情况下，当触及页面顶部或者底部时（或者是其他可滚动区域），  *  移动端浏览器倾向于提供一种“触底”效果，甚至进行页面刷新。  *  当对话框中含有可滚动内容时，一旦滚动至对话框的边界，对话框下方的页面内容也开始滚动了——这被称为“滚动链”。  *  [auto | contain | none]  */</code></pre>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>惬意</title>
      <link href="/2019/09/19/agreeable/"/>
      <url>/2019/09/19/agreeable/</url>
      
        <content type="html"><![CDATA[<p>杂绪</p><a id="more"></a><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=453268370&auto=1&height=66"></iframe><p>下地铁后，匆忙赶回去，已是饥肠辘辘。</p><p>路上，念着楼下那份流露着些许家乡味道的炒面，到底还是老乡的东西实惠，这次这么饿了，一定能吃完吧。</p><p>初秋的天，清凉的夜。</p><p>手捂着肚子已分不清是肚子疼还是饿得慌，脚步却从未减慢，漫长的红灯用头条来消磨依旧漫长。</p><p>“老板，一份..”</p><p>“炒面？”</p><p>“对”，我笑了笑。</p><p>七点五十的小餐馆已经开始收拾厨房碗筷了，随便找张桌子坐下，刷起手机，等待着大自然的馈赠。</p><p>饿到这种程度的我，还是意料之中的没有吃干净。</p><p>脱去白日的皮囊，一碗凉白开下肚，懒散地瘫在客厅椅上，什么都不想，什么都不听，安静的享受这厨房到客厅的穿堂风，带着丝丝凉意，却极为舒心。</p><p>惬意，无与伦比的惬意。</p><p>只有这刻，才给我感觉找回了零星几点灵魂。</p><p>许久，有些凉了，我站起身。</p><p>“今天不洗澡了”</p><p>妄想抓住灵魂的我 眼睁睁看它溜走</p><p>2019/09/19 星期四 晚 风大</p>]]></content>
      
      
      <categories>
          
          <category> 夜晚 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>H5通用功能点汇总</title>
      <link href="/2019/09/02/h5upup/"/>
      <url>/2019/09/02/h5upup/</url>
      
        <content type="html"><![CDATA[<blockquote><p>作为一名有操守的程序员，鄙人，只发干货！</p></blockquote><blockquote><p>此篇文章作为 h5 前端路上的功能点、工具总结；如有更好的方法，请在评论区留下你的身影</p></blockquote><a id="more"></a><p>连做三个 h5 项目，或多或少积累一点开发的经验，此篇文章一是记录，二为分享。</p><p>开整！</p><h2 id="基础环境"><a href="#基础环境" class="headerlink" title="基础环境"></a>基础环境</h2><p>三次项目皆使用 vue 框架开发，使用 vue-cli3.x 生成项目主体已是相当熟稔，<u><a href="https://cli.vuejs.org/zh/" target="_blank" rel="noopener">vue-cli 传送门</a></u>。</p><p>使用 axios 请求库，也可自行选择顺手的使用。</p><h2 id="微信-sdk-的再次封装"><a href="#微信-sdk-的再次封装" class="headerlink" title="微信 sdk 的再次封装"></a>微信 sdk 的再次封装</h2><p>微信官方提供一个 jsbridge 脚本，能够很方便的使用设备的一些功能及微信本身提供的功能。</p><p>我们需要做的是在项目中更好的调用它。</p><ul><li><p>在<code>public/index.html</code>模版 html 里的 head 中加入 wxsdk(<u><a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&id=mp1421141115" target="_blank" rel="noopener">传送门</a></u>)，或直接复制此条<code>http://res.wx.qq.com/open/js/jweixin-1.4.0.js</code>(微信目前最新版本 js)</p></li><li><p>在<code>src</code>目录下，我们创建一个<code>utils</code>文件夹内创建<code>wxsdk.js</code>，在其中加上</p></li></ul><pre><code class="javascript">import axios from &quot;axios&quot;;const wxsdk = {  init(url) {    // 顾名思义，用于初始化wxconfig的方法    return new Promise(resolve =&gt; {      axios        .get(&quot;请求微信config的后端接口&quot;, { params: { url } })        .then(({ appId, timestamp, nonceStr, signature }) =&gt; {          wx.config({            debug: false, // 后面可以用于调试config是否配置成功            appId,            timestamp,            nonceStr,            signature,            jsApiList: [              &quot;chooseImage&quot;,              &quot;uploadImage&quot;,              &quot;getLocalImgData&quot;,              &quot;updateAppMessageShareData&quot;,              &quot;updateTimelineShareData&quot;            ] // 在此注册你需要使用的api          });          resolve(); //  配置完成的promise回调        });    });  }};export default wxsdk;</code></pre><ul><li>下面把初始化方法放入全局的路由守卫中，使用户在每个页面打开时都注册一次。</li></ul><pre><code class="javascript">// router.js中import Vue from &#39;vue&#39;import Router from &#39;vue-router&#39;import wxsdk from &#39;../utils/wxsdk&#39;Vue.use(Router)const router = new Router({    //  没看错，使用的是hash，    //  使用hash是因为方便后端直接使用链接进行其他的带参操作    //  同时，也避免了在nginx中部署时对前端路由的操控    mode: &#39;hash&#39;,    routes: [...]})router.afterEach((to, from, next) =&gt; {    // 此处较为关键，由于我们使用的是单页应用，内部路由皆为虚拟路由，    // 并且是hash模式，需要获取 # 前的路由作为请求路径    wxsdk.init(location.href.split(&#39;#&#39;)[0])})export default router</code></pre><ul><li>加入一个封装上传本地图片方法作为例子</li></ul><pre><code class="js">chooseImage (count) {    return new Promise(resolve =&gt; {      wx.ready(() =&gt; {        wx.chooseImage({          count, //  用于控制上传图片的数量          sizeType: [&#39;original&#39;, &#39;compressed&#39;],          sourceType: [&#39;album&#39;, &#39;camera&#39;],          success: ({ localIds }) =&gt; {            resolve(localIds)          }        })      })    })},</code></pre><ul><li>若项目中有需要判断微信的 js 是否加载完毕，可以使用下面方法</li></ul><pre><code class="javascript">// wxsdk.js中const wxsdk = {    ...,    check (cb) {      if (typeof WeixinJSBridge === &#39;object&#39; &amp;&amp; typeof WeixinJSBridge.invoke === &#39;function&#39;) {        cb()      } else {        if (document.addEventListener) {          document.addEventListener(&#39;WeixinJSBridgeReady&#39;, cb, false)        } else if (document.attachEvent) {          document.attachEvent(&#39;WeixinJSBridgeReady&#39;, cb)          document.attachEvent(&#39;onWeixinJSBridgeReady&#39;, cb)        }      }    },}</code></pre><ul><li>可以在页面的<code>mounted</code>周期中引入</li></ul><pre><code class="vue">&lt;script&gt;export default {  mounted() {    this.$wxsdk.check(() =&gt; {      console.log(&quot;微信js加载完毕,进入页面&quot;);    });  }};&lt;/script&gt;</code></pre><ul><li>为了方便我们对 wxsdk 的使用，可以在<code>main.js</code>中将此对象挂载到 vue.prototype 上</li></ul><pre><code class="js">import wxsdk from &quot;./utils/wxsdk&quot;;Vue.prototype.$wxsdk = wxsdk;</code></pre><p>微信 jssdk 的封装使用基本完成。</p><h2 id="页面适配"><a href="#页面适配" class="headerlink" title="页面适配"></a>页面适配</h2><p>我使用的是 rem 单位布局，根据设配的屏幕宽度与设计稿的宽度比计算出根元素的像素大小，从而使一张设计图适配不同的手机屏幕</p><pre><code class="js">// utils/util.js中const deviceRem = size =&gt; {  const docEl = document.documentElement;  const clientWidth = docEl.clientWidth;  const reSize = () =&gt;    (docEl.style.fontSize =      clientWidth &gt;= size ? &quot;100px&quot; : 100 * (clientWidth / size) + &quot;px&quot;);  document.addEventListener(&quot;DOMContentLoaded&quot;, reSize, false);};deviceRem(1125);</code></pre><h2 id="第三方字体包"><a href="#第三方字体包" class="headerlink" title="第三方字体包"></a>第三方字体包</h2><p>根据 h5 的不同业务特点，可能需要引入各种个样的字体包，比如我的第一个 h5 就使用了<code>站酷快乐体xxx</code>的字体包</p><pre><code class="scss">@font-face {  font-family: &quot;happyFonts&quot;;  src: url(&quot;../fonts/站酷快乐体2016修订版.ttf&quot;);  font-weight: normal;  font-style: normal;}body {  font-family: &quot;happyFonts&quot;;}</code></pre><p>引入后，打包到线上环境测试发现，即使字体包用<code>font-spider</code>筛选一遍，可真机上打开或多或少会出现字体加载过慢，导致文字区域空白一段时间再出现，或者先出现系统默认字体，之后再突然出现字体包字体。</p><p>这种体验…很难受啊!</p><p>所以我们急需一个能够监听第三方字体包是否加载完成的方法。</p><p>抓耳挠腮，捶胸顿足之下，终于找到一个神器 <u><a href="https://github.com/bramstein/fontfaceobserver" target="_blank" rel="noopener">Font Face Observer</a></u>!!!</p><p>如同描述的一般，它提供两个回调函数，字体加载成功或失败，页面可以在其回调内决定是否出现。</p><pre><code class="js">import Font from &quot;fontfaceobserver&quot;;export default {  mounted() {    const font = new Font(&quot;happyFonts&quot;);    font.load().then(      () =&gt; {        console.log(&quot;字体加载完成&quot;);        this.$router.replace({ name: &quot;start&quot; });      },      () =&gt; {        console.log(&quot;字体加载失败&quot;);        this.$router.replace({ name: &quot;start&quot; });      }    );  }};</code></pre><h2 id="BGM"><a href="#BGM" class="headerlink" title="BGM!"></a>BGM!</h2><p>大部分活动 h5 少不了会用上 bgm，建议 bgm 使用某一段或几段可以循环播放的音频，越短越好(占用加载时间和服务器资源)。</p><p>“音频文件太长了，我只需要其中一小段怎么办”，我给出的方法是：<code>找一个会剪音乐的漂亮妹子，嘿嘿嘿(咽口水)</code>。</p><p>或者<u><a href="https://www.zhihu.com/question/19907593" target="_blank" rel="noopener">点击此处</a></u></p><p>好了，由于 h5 中的 bgm 占用了和字体包差不多的大小，我们也需要一个能够判断音频文件加载完成的事件。</p><p>下面是 audio 相关的事件</p><pre><code class="html">&lt;body&gt;  &lt;audio id=&quot;music&quot; src=&quot;&quot; loop=&quot;loop&quot;&gt;&lt;/audio&gt;  &lt;script&gt;    /**     * @func play 播放 可判断音频是否正在播放     * @func pause 暂停 可判断音频是否暂停     * @funcs  一下事件是音频在加载过程中依次触发的     * loadstart =&gt; durationchange =&gt; loadeddata =&gt; progress =&gt; canplay =&gt; canplaythrough     */    const audio = document.getElementById(&quot;music&quot;);    audio.oncanplay = () =&gt; {      console.log(&quot;音乐可以播放，做你想做的吧&quot;);    };  &lt;/script&gt;&lt;/body&gt;</code></pre><p>正在我志得意满打开测试链接时，发现无论如何点击播放都没有音乐声音！😱</p><p>着急忙慌打开微信开发者工具调试后发现，我的音乐地址找不到资源，这是为何？分明就放在<code>src/assets/music</code>中啊，找不到资源…难不成！</p><p>心头一点灵光乍现，当即打开<u><a href="https://vue-loader.vuejs.org/zh/options.html#transformasseturls" target="_blank" rel="noopener">vue-cli</a></u>，急急望去</p><pre><code class="js">{  video: [&#39;src&#39;, &#39;poster&#39;],  source: &#39;src&#39;,  img: &#39;src&#39;,  image: [&#39;xlink:href&#39;, &#39;href&#39;],  use: [&#39;xlink:href&#39;, &#39;href&#39;]}</code></pre><p>果然不出所料，vue-cli 的 loader 配置默认没有 audio 的配置！至此，情绪再次恢复平静，打开<code>vue.config.js</code>，缓缓书写几行代码</p><pre><code class="js">module.exports = {  assetsDir: &quot;static&quot;,  chainWebpack: config =&gt; {    config.module      .rule(&quot;vue&quot;)      .use(&quot;vue-loader&quot;)      .loader(&quot;vue-loader&quot;)      .tap(options =&gt; {        options.transformAssetUrls = {          audio: &quot;src&quot;        };        return options;      });  }};</code></pre><p>重新打包，点开<code>dist</code>文件夹，<code>static/media/xxx.mp3</code>已安稳的进入其中，吾心甚慰。</p><h2 id="html2canvas"><a href="#html2canvas" class="headerlink" title="html2canvas"></a>html2canvas</h2><p>h5 的最后推广，同样少不了的一个功能就是，生成图片。</p><p>对于生成图片，这里有两个模块可供使用<code>html2canvas</code>和<code>dom-to-image</code>，两个模块的使用方法都很简单，这里使用的是 html2canvas.</p><p>随之而来的就是老生常谈的两个问题，一是图片跨域问题，二是生成图片清晰度优化。</p><ul><li><p>图片跨域</p><p>启用 html2canvas 中的<code>{ useCORS: true }</code>配置，即可渲染 cdn 的图片和本地图片。</p><p>若有其他来源图片(比如微信用户头像)，要么走接口转化下图片链接，要么将图片转成 base64 格式再行渲染即可。</p></li><li><p>清晰度优化</p><ol><li>将选区 dom 的布局单位改为 px 像素</li><li>使用<code>{ scale: 2 }</code>将 canvas 的宽高扩大为原本 dom 的两倍，或设置为 devicePixelRatio 倍，最后将生成图片的大小设置为原先 dom 大小</li><li>可以使用 css 绘制的样式，尽量不要使用图片代替</li></ol><pre><code class="vue">&lt;script&gt;import html2canvas from &quot;html2canvas&quot;;export default {  // 获取可视区域的宽高  getClientSize() {    const app = this.$refs.app;    return [app.clientWidth, app.clientHeight];  },  // 生成图片  createPhoto() {    const content = document.getElementById(&quot;container&quot;);    const canvas = document.createElement(&quot;canvas&quot;);    const [width, height] = this.getClientSize();    const scale = 2;    canvas.width = width;    canvas.height = height;    canvas.getContext(&quot;2d&quot;).scale(scale, scale);    const opts = {      logging: true, //  打印生成图片的日志      canvas: canvas, //  导入生成的canvas      width: width,      height: height,      scale: scale,      useCORS: true, //  允许图片跨域      timeout: 1000 //  设置图片超时时间    };    html2canvas(content, opts).then(c =&gt; {      this.photo = c.toDataURL(&quot;image/png&quot;, 1);    });  }};&lt;/script&gt;</code></pre><p>完美~</p></li></ul><h2 id="图片压缩"><a href="#图片压缩" class="headerlink" title="图片压缩"></a>图片压缩</h2><p>图片压缩有我们熟知的<u><a href="https://tinypng.com/" target="_blank" rel="noopener">熊猫压缩</a></u>，这个在线压缩网站可以极大的减少图片的大小同时不会出现失真，但对于工程师来说，拖入本地图片压缩的做法未免略显蠢笨。</p><p>于是，有了这么一个图片压缩的工具<code>imageMin</code>，及其 webpack 的扩展<u><a href="https://github.com/Klathmon/imagemin-webpack-plugin" target="_blank" rel="noopener">imagemin-webpack-plugin</a></u>。</p><pre><code class="js">const ImageminPlugin = require(&#39;imagemin-webpack-plugin&#39;).defaultconst IS_PROD  = [&#39;production&#39;, &#39;prod&#39;].includes(process.env.NODE_ENV)  //  判断当前环境module.exports = {  configureWebpack: {    plugins: {      new ImageminPlugin({        disable: !IS_PROD,        pngquant: {          quality: &#39;80-100&#39;,  //  控制图片质量区间          progressive: true   //  图片加载时的显示方式是否是渐变出现        }      })    }  }}</code></pre><p>亲测实用，<code>image</code>文件夹原本 5mb(已被 tinypng 压缩)，打包后只有 3.5mb。</p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>一分钟速成科学上网教学</title>
      <link href="/2019/08/07/GFW/"/>
      <url>/2019/08/07/GFW/</url>
      
        <content type="html"><![CDATA[<blockquote><p>琐事缠身，许久未更博。为了找些乐子，不久前突发奇想，要搞一搞小程序。<br>怎么说也要搞台服务器玩一玩，最好能科学上网的国外海外服务器</p></blockquote><a id="more"></a><h2 id="挑选服务器"><a href="#挑选服务器" class="headerlink" title="挑选服务器"></a>挑选服务器</h2><hr><p>开始想着和二三好友一起开发小项目，支出可以平摊，首先就想到了国内两大云服务器巨头“<u><a href="https://cn.aliyun.com/" target="_blank" rel="noopener">阿里云</a></u>”、“<u><a href="https://cloud.tencent.com/" target="_blank" rel="noopener">腾讯云</a></u>”。</p><p>稍微看了一眼，“<code>1核1G 40GB 香港，差不多800一年</code>，不算贵嘛”，这边“<code>1核1G 香港，900出头</code>。哈，便宜”，这时的我颇有暴发户的感觉。<br>正准备点击下单，享受一把挥金似土感觉的时候，同事慢慢的靠近了我，“宇哥，要买服务器啊”</p><p>“也就一天零花钱的价格，随便买买。强哥有何指教”，我一个战术后仰，搭眼看向他，心中暗爽不已（没见过吧，这可是白花花的 900 大洋，哈哈哈哈，有钱真好）。想到这里，嘴角不自觉的扬起一抹弧度，“强哥，到时候搭梯子的时候还要多多帮忙啊”。</p><p>“要不你看看这个”，他看了我一眼，有种莫名的意味，“发你了”。</p><p>我被他看得莫名其妙（这不像是崇拜的目光啊），带着疑惑回头点开链接，脸色由狐疑到凝重，再到不可置信却含着一丝喜悦，然而再次转脸已回复平静，但是声音却颤抖着出卖了我“强哥..这是真的？”。</p><p>“想买吗？我教你啊”他洒然一笑，依旧是那般眼神。直到此刻，我终于懂了，那股眼神是对弱者的旁观和怜悯。</p><p>说了这么多，没有错！最后选择的就是<u><a href="https://bwg.net/" target="_blank" rel="noopener">搬瓦工</a></u>的服务器，中文看不懂的同学可以直接<u><a href="https://bwh88.net/" target="_blank" rel="noopener">进入官网</a></u>看英文版。</p><p><img src="https://ws1.sinaimg.cn/large/006665PZgy1g5ri7ptm3oj30sy0mxdhj.jpg" alt="搬瓦工" title="搬瓦工产品界面"></p><p>$49.99 / year!! 赶紧去百度下汇率换算，只要 353 元 RMB，就可以有一台<code>1核1G 20GB 每月1T流量</code>的海外服务器了？！<br><img src="https://ws1.sinaimg.cn/large/006665PZgy1g5riol9ldfj30f205874c.jpg" alt="搬瓦工" title="百度汇率换算"></p><p>“搬瓦工的中文网站里面还有优惠码，可以<code>再便宜6%</code>”</p><p>红豆泥！柴犬抱头.jpg… 我急急看去，果真是都有优惠码<code>BWH34QMFYT2R</code>，看来搬瓦工为了抢占市场，实在是下了本啊。<br>这么算下来，竟只要<code>$46.8 ===&gt; 330RMB</code>！要什么自行车 🚲？</p><p><img src="https://ws1.sinaimg.cn/large/006665PZgy1g5riypvnthj30rd0c3dg9.jpg" alt="搬瓦工" title="搬瓦工付款界面"></p><h2 id="注册账号"><a href="#注册账号" class="headerlink" title="注册账号"></a>注册账号</h2><p><img src="https://ws1.sinaimg.cn/large/006665PZgy1g5rj5o8k32j30sc0o278q.jpg" alt="搬瓦工" title="注册页面"></p><p>一张图，懂得自然懂。（你不说我懂个 P 啊！）</p><p>如图，注册账号中画圈的地方最好填真实地址，剩下的输入框随便填填就可以啦（大不了就等报错..）</p><h2 id="购买流程"><a href="#购买流程" class="headerlink" title="购买流程"></a>购买流程</h2><p>有帐号之后，点击 home 回到产品页面，选择你财力足够支撑的一款，在付款界面里，选择你有的付款方式。</p><p><img src="https://ws1.sinaimg.cn/large/006665PZgy1g5rjcp083dj30i9053jrd.jpg" alt="搬瓦工" title="付款页面"></p><h2 id="管理你的服务器"><a href="#管理你的服务器" class="headerlink" title="管理你的服务器"></a>管理你的服务器</h2><p>此时你也是有个人服务器的大佬了，那么如何管控你的服务器呢？</p><p>在搬瓦工主界面里，点击 Services =&gt; <u><a href="https://bwh88.net/clientarea.php?action=products" target="_blank" rel="noopener">My Services</a></u>，即可看到你所购买的所有服务器。</p><p>点击<u><a href="https://kiwivm.64clouds.com/main.php" target="_blank" rel="noopener">Control Panel</a></u>，会来到服务器的控制台面板。<br>各种操作，且听我慢慢道来…<br><img src="http://ww1.sinaimg.cn/large/006665PZgy1g5s86a10hjj32ak14i11i.jpg" alt="搬瓦工" title="服务器控制面板"></p><ul><li><p>Main controls(主控区域)</p><p>这里显示当前服务器的地址、IP、端口、目前内存、本月所剩流量等。这里也可以对服务器做开机、关机、重启、强制关机等</p></li><li><p>Private network(私有网络)</p><p>主要功能是同一数据中心的多台搬瓦工需要更好的通信、负载均衡、高速传输数据等。一般人应该用不上，就不细说。</p></li><li><p>Detailed Statistics(监控面板)</p><p>能够看到服务器每个时间段的 I/O、硬盘读写、cpu 占用率的变化波动。<br><img src="http://ww1.sinaimg.cn/large/006665PZgy1g5s9e2d9j7j32j20w0q91.jpg" alt="搬瓦工" title="服务器波动"></p></li><li><p>Root Shell - (basic | advanced | interactive)</p><p>在线版的 shell，可编写一些简单的命令(ssh 不香哦)，基本不用，跳过。</p></li><li><p>Install new OS(重装系统)</p><p>服务器默认是 centos7 的系统，有高手不喜欢的可以换成 debian，有富家子弟不喜欢命令行的可以换成 ubuntu。</p></li><li><p>Two-factor authentication(双重身份验证)</p><p>简称为二级校验。</p></li><li><p>Root password modification(修改密码)</p><p>系统会随机生成一串字符作为你的新密码</p></li><li><p>KiwiVM password modification(修改搬瓦工的登录密码)</p></li><li><p>Audit log(记录你在控制台的操作日志)</p></li></ul><h2 id="科-学-上-网"><a href="#科-学-上-网" class="headerlink" title="科!学!上!网!"></a>科!学!上!网!</h2><blockquote><p>哔哔哔这么多，你倒是说怎么出门看世界啊<br>干货来了～</p></blockquote><h3 id="服务器配置"><a href="#服务器配置" class="headerlink" title="服务器配置"></a>服务器配置</h3><ul><li><p>科学上网自然会想到大名鼎鼎的<code>Shadowsocks</code><u><a href="https://github.com/elegantYU/shadowsocks" target="_blank" rel="noopener">点击此链</a></u>，由于怕被封，所以 fork 了一份，也可以在<u><a href="https://github.com" target="_blank" rel="noopener">GitHub</a></u>自行搜索。</p></li><li><p>使用 ssh 命令进入服务器</p></li></ul><pre><code class="bash">ssh root@你的服务器IP -p 服务器端口</code></pre><ul><li>我的是 centos 的服务器，所以输入以下命令</li></ul><pre><code class="bash">yum install python-setuptoolseasy_install pippip install shadowsocks</code></pre><ul><li>下载完 shadowsocks 后，开始创建配置文件</li></ul><pre><code class="bash"># 在/etc/下新建shadowsocks.json文件vi /etc/shadowsocks.json</code></pre><p>shadowsocks.json 配置文件</p><pre><code class="json">{  &quot;server&quot;: &quot;服务器IP&quot;,  &quot;server_port&quot;: 8388, //  服务器端口(对外暴露)，可自定义  &quot;local_address&quot;: &quot;127.0.0.1&quot;,  &quot;local_port&quot;: 1080, //  本地服务使用的端口  &quot;password&quot;: &quot;自己想点复杂的密码&quot;,  &quot;timeout&quot;: 300,  &quot;methods&quot;: &quot;aes-256-cfb&quot;, //  选择一个加密方式  &quot;fast_open&quot;: false, //  是否使用TCP_FASTOPEN  &quot;workers&quot;: 1}</code></pre><ul><li>配置完成后，我们来启动服务</li></ul><pre><code class="bash"># 使用此命令，shadowsocks将在前台运行ssserver -c /etc/shadowsocks.json# ctrl + c || command + c 停止服务</code></pre><pre><code class="bash"># 此命令下，shadowsocks会在后台运行ssserver -c /etc/shadowsocks.json -d startssserver -c /etc/shadowsocks.json -d stop</code></pre><h3 id="客户端配置-MacOS-amp-windows-amp-android-amp-chrome"><a href="#客户端配置-MacOS-amp-windows-amp-android-amp-chrome" class="headerlink" title="客户端配置(MacOS &amp; windows &amp; android &amp; chrome)"></a>客户端配置(MacOS &amp; windows &amp; android &amp; chrome)</h3><ol><li><p>MacOS</p><ul><li><p>下载<u><a href="https://github.com/shadowsocks/ShadowsocksX-NG/releases" target="_blank" rel="noopener">ShadowsocksX-NG</a></u>，如图<br><img src="http://ww1.sinaimg.cn/large/006665PZgy1g5sfg2u53hj31l010ate4.jpg" alt="shadowsocks" title="mac工具"></p></li><li><p>安装之后，会在顶部任务栏多出一个小飞机，点击飞机，选择服务器设置<br><img src="http://ww1.sinaimg.cn/large/006665PZgy1g5sfk26h91j30u00oiqkb.jpg" alt="shadowsocks" title="mac工具"></p></li><li><p>添加你的服务器设置，填写 ip，对外暴露的端口号，设置的密码，设置的加密方式<br><img src="http://ww1.sinaimg.cn/large/006665PZgy1g5sgtuzzb8j30uy0hy762.jpg" alt="shadowsocks" title="mac工具"></p></li><li><p>查看本地对外的端口(浏览器使用)，点击偏好设置，这里的本地监听 Socks5 端口记住了，后面就是在浏览器中配置的。<br><img src="http://ww1.sinaimg.cn/large/006665PZgy1g5tkmumty2j30qo0mg777.jpg" alt="shadowsocks" title="mac工具"></p></li></ul></li><li><p>windwos</p><ul><li><p>下载<u><a href="https://github.com/shadowsocks/shadowsocks-windows/releases" target="_blank" rel="noopener">Shadowsocks-windows</a></u>，如图<br><img src="https://ws1.sinaimg.cn/large/006665PZly1g5ueft87rrj30rb0njwfm.jpg" alt="shadowsocks" title="windows工具"></p></li><li><p>同样，安装之后双击打开小飞机，开始编辑服务器配置及本地代理端口<br><img src="https://ws1.sinaimg.cn/large/006665PZly1g5ueis02oqj30cx0d70sx.jpg" alt="shadowsocks" title="windows工具"><br>编辑完成后可以直接 chrome 浏览器配置</p></li></ul></li><li><p>android</p><ul><li><p>下载<u><a href="https://github.com/shadowsocks/shadowsocks-android/releases" target="_blank" rel="noopener">shadowsocks-android</a></u>apk<br><img src="https://ws1.sinaimg.cn/large/006665PZly1g5uf3446cjj30r60jhjsg.jpg" alt="shadowsocks-android" title="shadowsocks-android"></p></li><li><p>后面操作就不多言了，懂的都懂</p></li><li><p>配置完成后，手机打开<u><a href="https://www.google.com" target="_blank" rel="noopener">谷歌搜索</a></u>，即可使用</p></li></ul></li><li><p>chrome</p><ul><li><p>打开<u><a href="https://chrome.google.com/webstore/category/extensions?hl=zh-CN" target="_blank" rel="noopener">chrome 应用商店</a></u>（无法打开的童鞋可以看最后的 tips），搜索 Proxy SwitchyOmega<br><img src="https://ws1.sinaimg.cn/large/006665PZly1g5ueoo2jlwj30tl0neq4a.jpg" alt="SwitchyOmega" title="SwitchyOmega"></p></li><li><p>安装成功后，点开选项进行配置<br><img src="https://ws1.sinaimg.cn/large/006665PZly1g5uer6yrpgj305a072jrc.jpg" alt="SwitchyOmega" title="SwitchyOmega"><br>选择 proxy，输入本地代理地址，及本地代理端口<br><img src="https://ws1.sinaimg.cn/large/006665PZly1g5ueuduracj30x90ddaap.jpg" alt="SwitchyOmega" title="SwitchyOmega"><br>应用选项！</p></li></ul></li></ol><p>现在，打开<a href="https://www.youtube.com/" target="_blank" rel="noopener">Youtube</a>试一下。<br>恭喜你已经成功科学上网了</p><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><p>无法进入谷歌商店下载插件的，可以先使用<u><a href="https://chrome.zzzmh.cn/info?token=gocklaboggjfkolaknpbhddbaopcepfp" target="_blank" rel="noopener">谷歌访问助手</a></u>，作为临时的科学上网，它提供了搜索，邮箱，商店的服务。不过作为免费的插件，其速度及上网能力肯定不及个人的服务器。</p><p>本次教程结束，愿各位人人有网上。</p>]]></content>
      
      
      <categories>
          
          <category> 一分钟教程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>一分钟速成hexo搭建博客教学</title>
      <link href="/2019/04/18/learn_hexo/"/>
      <url>/2019/04/18/learn_hexo/</url>
      
        <content type="html"><![CDATA[<blockquote><p>此篇博客乃在下历时月许，拖沓至今才准备出的 hexo+github 搭建博客教学。<br>从头至尾皆是本人的亲生体会，希望对大家有所借鉴和帮助</p></blockquote><a id="more"></a><p><a href="https://github.com/996icu/996.ICU/blob/master/LICENSE" target="_blank" rel="noopener"><img src="https://img.shields.io/badge/license-Anti%20996-blue.svg" alt="LICENSE"></a></p><div class="aplayer" data-name='to the seaside...' data-artist='silky soap' data-url='http://m10.music.126.net/20200405204825/5e96a995cd8b00ca7280bff3714f945a/ymusic/e68a/99ca/72e6/3c2ea48d52fa82faf8380fdff28772e9.mp3' data-lrc data-cover='https://i.loli.net/2020/04/05/5Sv8WXw2RKpDIsT.jpg' ></div><h2 id="博客环境"><a href="#博客环境" class="headerlink" title="博客环境"></a>博客环境</h2><ol><li><p><u><a href="https://nodejs.org/zh-cn/" target="_blank" rel="noopener">Node.js</a></u>你要有吧，版本当然是越新越好，越稳定越好;</p></li><li><p><u><a href="https://git-scm.com/downloads" target="_blank" rel="noopener">Git</a></u> 你要有吧，不用多说</p></li><li><p>安装 Hexo-cli，命令行全局下载</p><blockquote><p>npm install -g hexo-cli</p></blockquote></li><li><p>找一个你喜欢的位置，初始化 hexo 文件作为你的博客本地仓库</p><pre><code class="bash">$ hexo init &lt;你的仓库名&gt;$ cd &lt;你的仓库名&gt;$ npm install</code></pre></li><li><p>本地启动 hexo 博客</p><pre><code class="bash">$ hexo s</code></pre></li><li><p>本地博客在<code>http://localhost:4000</code>启动了！</p></li></ol><h2 id="github-仓库"><a href="#github-仓库" class="headerlink" title="github 仓库"></a>github 仓库</h2><ol><li><p>在 github 上创建名为 <code>&lt;你的Github帐号&gt;.github.io</code> 的仓库</p></li><li><p>使用命令，将本地 hexo 博客的仓库推送到 github 仓库(加入的命令越多，构建越慢)</p><ul><li>安装 <code>hexo-deployer-git</code> 插件</li></ul><pre><code class="bash">$ npm install hexo-deployer-git</code></pre><ul><li>修改本地仓库根目录下的_config.yml 文件中的</li></ul><pre><code class="yml"># Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:  type: git  repo: git@github.com:&lt;你的git账户名&gt;/&lt;你的git账户名&gt;.github.io  branch: master</code></pre><ul><li>使用 hexo 的推送命令</li></ul><pre><code class="bash">$ hexo g$ hexo d</code></pre></li><li><p>上个厕所，喝杯茶，等一会~在浏览器访问 <code>https://&lt;你的git账户名&gt;.github.io</code> 即可看到你的博客</p></li></ol><h2 id="添加主题"><a href="#添加主题" class="headerlink" title="添加主题"></a>添加主题</h2><ol><li><p>hexo 的默认主题是 landscape，虽然是很丑，但是确实不好看，这里列举几个我觉得 UI 或功能性好的主题</p><ul><li><u><a href="https://github.com/theme-next/hexo-theme-next" target="_blank" rel="noopener">Next</a></u> 大佬都在推</li><li><u><a href="https://github.com/0x2E/Material-T" target="_blank" rel="noopener">Material-T</a></u> 我在用的</li><li><u><a href="https://github.com/EYHN/hexo-theme-one" target="_blank" rel="noopener">One</a></u> 二次元大佬</li><li><u><a href="https://github.com/fi3ework/hexo-theme-archer" target="_blank" rel="noopener">Archer</a></u> 功能全面</li><li><u><a href="https://github.com/Longlongyu/hexo-theme-Cxo" target="_blank" rel="noopener">Cxo</a></u> 一开始的选择</li></ul><p>更多主题<u><a href="https://github.com/search?q=hexo-theme" target="_blank" rel="noopener">点这里</a></u>或<u><a href="https://hexo.io/themes/index.html" target="_blank" rel="noopener">这里</a></u></p></li><li><p>下载主题</p><ul><li>将下载的主题文件夹，粘贴到根目录的 thems 目录下(有些是直接下载到该目录下)</li><li>修改_config.yml 的 theme 配置<pre><code class="yml"># Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: &lt;你的主题名&gt;</code></pre></li></ul></li><li><p>主题优化<br>一般主题的文档中都会有相应的主题自定义优化空间，不然就自己添加配置</p></li></ol><h2 id="自动构建"><a href="#自动构建" class="headerlink" title="自动构建"></a>自动构建</h2><ol><li><p>什么是自动构建？</p><p>指将源码转换为可以实际运行的代码，配置各种资源(css、js、img 等)</p></li><li><p>hexo 为什么要自动构建？</p><blockquote><p>大家可以看下自己 github 的博客仓库，细心的你会惊讶的发现，怎么目录和本地仓库的不一样？<br>这是因为 hexo 在 deploy 的时候会把生成的代码上传到 git 仓库里，而开发环境的源码都不会上传，这样的话对于有多个终端的用户来说就很蛋疼。总不能说换个电脑就要从头来一遍博客的搭建吧…<br>于是，我们就需要在 git 仓库里也要上传一份源码，便于以后可以在不同的终端环境下也能方便的编辑博客。</p></blockquote><p>这里我使用的构建工具是<u><a href="https://travis-ci.org/" target="_blank" rel="noopener">Travis-CI</a></u></p></li><li><p>travis-ci 配置</p><ul><li>Travis-CI 是开源持续集成构建项目，用来构建托管在 github 上的代码，提供了多种语言的支持。</li></ul><p>当我们每次进行<code>git push</code>等动作时，Travis CI 会自动检测提交，然后根据<code>.travis.yml</code>配置文件自动生成一份线上代码。</p><ul><li><p>使用你的 git 账户登录<u><a href="https://travis-ci.org/" target="_blank" rel="noopener">Travis-CI</a></u>，进入<u><a href="https://travis-ci.org/account/repositories" target="_blank" rel="noopener">travis-ci.org/account/repositories</a></u>页面，如下图</p><p><img src="https://i.loli.net/2019/04/21/5cbc1252a36f5.png" alt="travis配置" title="travis ci 个人仓库"></p></li><li><p>点击<code>&lt;你的git名&gt;.github.io</code>仓库后的 settings，进入设置页</p><p><img src="https://i.loli.net/2019/04/21/5cbc1252a303e.png" alt="travis配置" title="travis ci 仓库配置"></p></li><li><p>在这里需要配置你的环境变量(Environment Variables)，起一个你觉得好听的名字(我这里叫<code>ACCESS_TOKEN</code>)，然后去 github 获取 token</p><p><img src="https://i.loli.net/2019/04/21/5cbc1462546f3.png" alt="travis配置" title="环境变量"></p></li><li><p>进入<a href="https://github.com/settings/developers" target="_blank" rel="noopener">github.com/settings/developers</a>页面，点击<code>Personal access tokens</code>，选择生成一个新 token(Generate new token)</p></li><li><p>选择 repo 所有权限</p><p><img src="https://i.loli.net/2019/04/21/5cbc1252ba0e6.png" alt="Generate new token" title="生成access_token"></p></li><li><p>将生成的 token 复制，粘贴到 travis ci 页面的 value 里(此 token 以后在 github 中不会再次显示，若是忘记可再次生成一个)，添加进去</p></li><li><p>下面就是配置.travis.yml 文件</p><ul><li><p>在本地博客根目录下新建.travis.yml 文件</p></li><li><p>配置如下(简易版)</p></li></ul><pre><code class="yml"># 指定语言环境language: node_js# 指定nodejs版本node_js: 10.15.3# 指定缓存模块，可加快编译速度(可选)cache:  directories:    - node_modules# 指定源码所在分支branches:  only:    - dev# 构建前执行的命令before_script:  - git config user.name &quot;&lt;你的git账户名&gt;&quot;  - git config user.email &quot;&lt;你的邮箱&gt;&quot;  # 这里的 ${ACCES_TOKEN} 对应之前在travis中设置的环境变量名  - sed -i&#39;&#39; &quot;s~https://github.com/&lt;你的git账户名&gt;/&lt;你的git账户名&gt;.github.io.git~https://${ACCESS_TOKEN}@github.com/&lt;你的git账户名&gt;/&lt;你的git账户名&gt;.github.io.git~&quot; _config.yml# 构建所执行命令script:  - hexo clean  - hexo g  - hexo d</code></pre><ul><li>修改根目录下的_config.yml</li></ul><pre><code class="yml">deploy:type: git# 使用https的urlrepo: https://github.com/&lt;你的git账户名&gt;/&lt;你的git账户名&gt;.github.io.gitbranch: master</code></pre></li><li><p>至此基本配置完毕，现在来提交下看是否开始自动构建</p><ul><li>在本地输入</li></ul><pre><code class="bash">$ git init$ git remote add origin &lt;git仓库的ssh链接&gt;$ git checkout -b dev$ git add</code></pre><ul><li>这时候可能会报错<code>You&#39;ve added another git repository inside your current repository.</code>, 这是因为主题文件和本地文件隶属两个不同的仓库，那么这时候就需要</li></ul><pre><code class="bash">$ git rm --cache &lt;报错主题的路径eg: theme/Material-T&gt;$ git add &lt;报错主题路径后加斜杠eg: theme/Material-T/&gt;</code></pre><p>git add 的时候在路径后加斜杠，表示将这个文件夹加入，而不是将这个文件作为一个子模块</p><ul><li>再次</li></ul><pre><code class="bash">$ git add .$ git commit -m &#39;first commit&#39;$ git push</code></pre></li><li><p>喝杯水回来，再上 travis 上看下，出现该仓库的提交信息时。<br>恭喜你！只用了一分钟就配置好了一个完美的 github+hexo 博客！</p></li></ul></li></ol><blockquote><p>重要功能已经具备，以后就是各种 hexo 插件的安装和配置，将会不断(慢)的更新。</p></blockquote><h2 id="写博客"><a href="#写博客" class="headerlink" title="写博客"></a>写博客</h2><pre><code class="bash">$ hexo new post &#39;你的博客名称&#39; // 新建的md会在/source/_post/文件夹中$ hexo clean                  // 删除和清理之前生成的不需要的文件$ hexo g                      // 生成文件$ hexo d                      // 上传git$ hexo s                      // 本地预览// 配置完CI后 hexo g 和 hexo d无需使用$ git add .$ git commit$ git push</code></pre><h2 id="hexo-扩展插件"><a href="#hexo-扩展插件" class="headerlink" title="hexo 扩展插件"></a>hexo 扩展插件</h2><h4 id="留言系统-gitment"><a href="#留言系统-gitment" class="headerlink" title="留言系统(gitment)"></a>留言系统(gitment)</h4><p>留言系统基本有 Valine,Livere,Gitment,Disqus 几种，这里选择的是 Gitment(大家都是有 gitment 帐号的人了)，所有的评论会已提交 issue 的形式保存在配置的仓库中。<br>下面，开始干货输出。</p><ul><li><p>注册 gitment,在<u><a href="https://github.com/settings/applications/new" target="_blank" rel="noopener">New OAuth App</a></u>为博客创建一个密钥</p><p><img src="http://ww1.sinaimg.cn/large/006665PZgy1g2e2uilm1cj30m00fr74y.jpg" alt="get info" title="生成密钥"></p><pre><code class="yml">Application name: &quot;给你放置评论的仓库起名&quot;Homepage URL: &quot;可以直接填你的博客链接&quot;Application deccription: &quot;描述...&quot;Authorization callback URL: &quot;这个必须填博客地址&quot;# 注意 Homepage 和 callback 的url后都要加 / (这里也是一个坑)# 例 https://elegantyu.github.io/</code></pre></li><li><p>在你博客主题里找到或添加</p><pre><code class="yml">gitment:enable: truemint: true # RECOMMEND, A mint on Gitment, to support count, language and proxy_gatewaycount: true # Show comments count in post meta arealazy: false # Comments lazy loading with a buttoncleanly: false # Hide &#39;Powered by ...&#39; on footer, and morelanguage: # Force language, or auto switch by themegithub_user: 你的github IDgithub_repo: 刚才填的仓库名(注意，只要名字，不要链接)client_id: 刚才申请的ClientIDclient_secret: 刚才申请的Client Secretproxy_gateway: # Address of api proxy, See: https://github.com/aimingoo/intersectredirect_protocol: # Protocol of redirect_uri with force_redirect_pro</code></pre></li><li><p>添加 gitment.ejs</p><p>有的主题有，我的是自行创建的。</p><pre><code class="html">&lt;!-- 放gitment的div --&gt;&lt;div id=&quot;gitment&quot;&gt;&lt;/div&gt;&lt;!-- 下面两个链接时助你越过一个大坑 --&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/gh/theme-next/theme-next-gitment@1/gitment.browser.js&quot;&gt;&lt;/script&gt;&lt;link  rel=&quot;stylesheet&quot;  href=&quot;https://cdn.jsdelivr.net/gh/theme-next/theme-next-gitment@1/default.css&quot;/&gt;&lt;!-- 初始化gitment实例 --&gt;&lt;script&gt;  let gitment = new Gitment({    // 关于id这一点要重点说下，这里又是一个大坑，在下面细说    id: &quot;&lt;%= page.subtitle %&gt;&quot;,    // 这里要注意映入yml里面的配置 要加上theme,不然默认引入最外层的config.yml    owner: &quot;&lt;%= theme.gitment.github_user %&gt;&quot;,    repo: &quot;&lt;%= theme.gitment.github_repo %&gt;&quot;,    oauth: {      client_id: &quot;&lt;%= theme.gitment.client_id %&gt;&quot;,      client_secret: &quot;&lt;%= theme.gitment.client_secret %&gt;&quot;    }  });  gitment.render(&quot;gitment&quot;);&lt;/script&gt;</code></pre></li><li><p>初始化 gitment</p><p>啥都整差不多了，只需<code>add commit push</code>三步走。部署完成后，在文章页面找到你的留言区域，使用你的 Git 帐号登录授权，然后点击出现的蓝色按钮，初始化！</p><p>初始化完成后还不留言测试下？</p><p>‘comment’！这时候可以去你的博客留言仓库看下，会发现<code>issue</code>板块多了你的文章标题，并且其中还有你的测试信息。那么恭喜你，gitment 搭建完毕，剩下的就是根据你的喜好改变样式了。</p></li><li><p>gitment 的坑</p><ul><li><p>gitment 原始的 js、css 外链因为作者已经不维护，其内部有个请求的 url 已不存在，会导致 gitment 的主人初始化一直转圈圈。就用我这个吧，这是被大佬们 down 下来加了 cdn 的，稳。</p></li><li><p>初始化实例的 id。此 id 默认是获取文章的 title 作为 id，这就意味着你的文章标题不能够恣意洒脱的长短由心。吾辈中人岂能受这气？尤其是像我这样标题喜欢浪的。苦苦寻觅之下，终得一良方，便是在文章的 Front Matter(md 文章最上边的变量区域)里加入一个变量<code>subtitle</code>，并将其赋值给 id。</p><pre><code class="markdown">---title: 一分钟速成hexo搭建博客教学subtitle: learn hexodate: 2019-04-18 22:12:46tags: 教程---</code></pre><p>如此这般，即可解决此大坑。</p><p>另外，为了方便以后的使用，可以在<code>/scaffolds/post.md</code>中，加入此变量。</p><pre><code class="md">---title: {{ title }}subtitle:date: {{ date }}tags:---</code></pre></li></ul></li></ul><h4 id="网易云音乐"><a href="#网易云音乐" class="headerlink" title="网易云音乐"></a>网易云音乐</h4><ul><li><p>进入<u><a href="https://music.163.com/" target="_blank" rel="noopener">网易云音乐</a></u>，选择你喜欢的歌，点击<code>生成外链播放器</code>，就可得到一个 html 的 iframe 标签</p></li><li><p>插进去</p></li></ul><h4 id="代码高亮的-mac-panel-样式"><a href="#代码高亮的-mac-panel-样式" class="headerlink" title="代码高亮的 mac panel 样式"></a>代码高亮的 mac panel 样式</h4><blockquote><p>这里不得不说下写博客的其中一条初衷，那就是让更多人从<code>百度</code>这种**搜索引擎的重复答案中，能找到几篇文章是不浑水摸鱼、CV 大师的。</p></blockquote><ul><li><p>在搜寻更好看，简约的高亮主题中，我被这款迷住了双眼。果然，设计领域中只有 mac 设计和仿 mac 设计。话不多说，下面是这种风格效果的实现</p></li><li><p>首先，我们要知道 <code>mac panel</code> 这种效果并不是一种代码高亮的主题，其只是在代码区域外层做的一个样式包裹。所以，我们的主要问题和解决途径就是如何修改代码的外围区域</p></li><li><p>我们在博客的根目录下创建一个<code>scripts</code>文件夹，其中放置一些我们需要的全局脚本文件</p></li><li><p>新建<code>codeblock.js</code>文件，在其中我们使用 hexo 的 api<code>after_post_render</code>，用于在文章页渲染时做代码区域的处理</p></li><li><p>主要代码构成如下（这里无需引入什么模块，hexo 执行相关命令的时候会自动访问）</p><pre><code class="javascript">const attributes = [  // 用于panel外层div的属性  &#39;autocomplete=&quot;off&quot;&#39;,  &#39;autocorrect=&quot;off&quot;&#39;,  &#39;autocapitalize=&quot;off&quot;&#39;,  &#39;spellcheck=&quot;false&quot;&#39;,  &#39;contenteditable=&quot;true&quot;&#39;];const attributesStr = attributes.join(&quot; &quot;);// 此方法可以获取所有文章的全部内容，具体可以打印 datahexo.extend.filter.register(&quot;after_post_render&quot;, data =&gt; {  // 这里是使用while持续获取匹配到的代码区域的dom标签  // 这里可能就有人问&#39;为什么别人的文章都是/&lt;figure ***&gt;/你的是/&lt;pre&gt;***/&#39;  // 你说为啥不一样，我们用的不是一个主题呗，这里的正则是根据你当前主题内文章渲染后代码区域的dom标签来定  // 查看dom都会吧  while (/&lt;pre&gt;(([\s\S])*?)&lt;\/pre&gt;/.test(data.content)) {    // 之后的操作就是将匹配到的标签，在其外层拼接一个div，然后返回所有文章    data.content = data.content.replace(/&lt;pre&gt;(([\s\S])*?)&lt;\/pre&gt;/, () =&gt; {      let lastMatch = RegExp.lastMatch;      let language =        RegExp.$1.match(/(?&lt;= )class=&quot;.*?&quot;/)[0].split(&quot;=&quot;)[1] || &quot;plain&quot;;      lastMatch = lastMatch.replace(/&lt;pre&gt;/, &#39;&lt;pre class=&quot;iseeu&quot;&gt;&#39;);      return `&lt;div class=&quot;highlight-wrap&quot;${attributesStr} data-rel=${language.toUpperCase()}&gt;${lastMatch}&lt;/div&gt;`;    });  }  return data;});</code></pre></li><li><p><code>highlight-wrap</code>的 css 样式，写在你的主题目录下的全局 css/less/scss/…文件中</p><pre><code class="css"> /* mac panel */  .highlight-wrap[data-rel] {    position: relative;    overflow: hidden;    border-radius: 5px;    box-shadow: 0 10px 30px 0px rgba(0,0,0,0.4);    margin: 35px 0;   }  .highlight-wrap[data-rel] ::-webkit-scrollbar {     height: 10px;   }   .highlight-wrap[data-rel] ::-webkit-scrollbar-track {     -webkit-box-shadow: inset 0 0 6px rgba(0,0,0,0.3);     border-radius: 10px;   }   .highlight-wrap[data-rel] ::-webkit-scrollbar-thumb {     border-radius: 10px;     -webkit-box-shadow: inset 0 0 6px rgba(0,0,0,0.5);   }   .highlight-wrap[data-rel] ::before {     color: white;     content: attr(data-rel);     height: 38px;     line-height: 38px;     background: #21252b;     color: #fff;     font-size: 16px;     position: absolute;     top: 0;     left: 0;     width: 100%;     font-family: &#39;Source Sans Pro&#39;, sans-serif;     font-weight: bold;     padding: 0px 80px;     text-indent: 15px;     float: left;   }   .highlight-wrap[data-rel] ::after {     content: &quot; &quot;;     position: absolute;     -webkit-border-radius: 50%;     border-radius: 50%;     background: #fc625d;     width: 12px;     height: 12px;     top: 0;     left: 20px;     margin-top: 13px;     -webkit-box-shadow: 20px 0px #fdbc40, 40px 0px #35cd4b;     box-shadow: 20px 0px #fdbc40, 40px 0px #35cd4b;     z-index: 3;   }   .highlight-wrap[data-rel] pre {     margin: 0;     padding: 40px 0 10px;   }</code></pre></li><li><p>全部配置完毕，运行<code>hexo s</code>，查看运行效果，基本上就已经完成了(css 细节自行调节)</p></li></ul><h4 id="live2d-动画"><a href="#live2d-动画" class="headerlink" title="live2d 动画"></a>live2d 动画</h4><p>加入右下角可爱的动画人物</p><ul><li><p>安装步骤 <a href="https://github.com/EYHN/hexo-helper-live2d/blob/master/README.zh-CN.md" target="_blank" rel="noopener">看这里</a></p></li><li><p>各种<a href="https://huaji8.top/post/live2d-plugin-2.0/" target="_blank" rel="noopener">看板娘演示 demo</a></p></li></ul><h4 id="不蒜子统计"><a href="#不蒜子统计" class="headerlink" title="不蒜子统计"></a>不蒜子统计</h4><p>使用不蒜子统计博客的 uv,pv.</p><ul><li><p>在主题下<code>/layout/_partial/footer.js</code>中引入不蒜子脚本<br><code>js &lt;script async src=&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;</code></p></li><li><p>pv &amp;&amp; uv 的显示</p><pre><code>    ```html    &lt;!-- 站点总访问量(总pv) --&gt;    &lt;span id=&quot;busuanzi_container_site_pv&quot;&gt;        总访问量&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;    &lt;/span&gt;    &lt;!-- 当前页面访问量(单页pv) --&gt;    &lt;span id=&quot;busuanzi_container_page_pv&quot;&gt;当前页面访问量&lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt;    &lt;/span&gt;    &lt;!-- 站点所有进入用户数(总uv) --&gt;    &lt;span id=&quot;busuanzi_container_site_uv&quot;&gt;本站访客数&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;    &lt;/span&gt;    ```</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 一分钟教程 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
